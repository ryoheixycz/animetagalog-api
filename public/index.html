<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Anime API Admin</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <script src="https://unpkg.com/@phosphor-icons/web"></script>
  <style>
    :root {
      /* Base colors */
      --background: 0 0% 100%;
      --foreground: 222.2 84% 4.9%;
      
      /* Card colors */
      --card: 0 0% 100%;
      --card-foreground: 222.2 84% 4.9%;
      
      /* Popover colors */
      --popover: 0 0% 100%;
      --popover-foreground: 222.2 84% 4.9%;
      
      /* Primary colors */
      --primary: 221.2 83.2% 53.3%;
      --primary-foreground: 210 40% 98%;
      
      /* Secondary colors */
      --secondary: 210 40% 96.1%;
      --secondary-foreground: 222.2 47.4% 11.2%;
      
      /* Muted colors */
      --muted: 210 40% 96.1%;
      --muted-foreground: 215.4 16.3% 46.9%;
      
      /* Accent colors */
      --accent: 210 40% 96.1%;
      --accent-foreground: 222.2 47.4% 11.2%;
      
      /* Destructive colors */
      --destructive: 0 84.2% 60.2%;
      --destructive-foreground: 210 40% 98%;
      
      /* Border colors */
      --border: 214.3 31.8% 91.4%;
      
      /* Input colors */
      --input: 214.3 31.8% 91.4%;
      
      /* Ring colors */
      --ring: 221.2 83.2% 53.3%;
      
      /* Radius */
      --radius: 0.5rem;
    }
    
    .dark {
      /* Base colors - dark */
      --background: 222.2 84% 4.9%;
      --foreground: 210 40% 98%;
      
      /* Card colors - dark */
      --card: 222.2 84% 4.9%;
      --card-foreground: 210 40% 98%;
      
      /* Popover colors - dark */
      --popover: 222.2 84% 4.9%;
      --popover-foreground: 210 40% 98%;
      
      /* Primary colors - dark */
      --primary: 217.2 91.2% 59.8%;
      --primary-foreground: 222.2 47.4% 11.2%;
      
      /* Secondary colors - dark */
      --secondary: 217.2 32.6% 17.5%;
      --secondary-foreground: 210 40% 98%;
      
      /* Muted colors - dark */
      --muted: 217.2 32.6% 17.5%;
      --muted-foreground: 215 20.2% 65.1%;
      
      /* Accent colors - dark */
      --accent: 217.2 32.6% 17.5%;
      --accent-foreground: 210 40% 98%;
      
      /* Destructive colors - dark */
      --destructive: 0 62.8% 30.6%;
      --destructive-foreground: 210 40% 98%;
      
      /* Border colors - dark */
      --border: 217.2 32.6% 17.5%;
      
      /* Input colors - dark */
      --input: 217.2 32.6% 17.5%;
    }
    
    * {
      border-color: hsl(var(--border));
    }
    
    body {
      font-family: 'Outfit', sans-serif;
      background-color: hsl(var(--background));
      color: hsl(var(--foreground));
    }
    
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius);
      font-weight: 500;
      transition: all 0.2s ease;
      padding: 0.5rem 1rem;
      cursor: pointer;
    }
    
    .btn-sm {
      height: 2rem;
      padding-left: 0.75rem;
      padding-right: 0.75rem;
      font-size: 0.875rem;
    }
    
    .btn-primary {
      background-color: hsl(var(--primary));
      color: hsl(var(--primary-foreground));
    }
    
    .btn-primary:hover {
      opacity: 0.9;
    }
    
    .btn-secondary {
      background-color: hsl(var(--secondary));
      color: hsl(var(--secondary-foreground));
    }
    
    .btn-secondary:hover {
      opacity: 0.9;
    }
    
    .btn-destructive {
      background-color: hsl(var(--destructive));
      color: hsl(var(--destructive-foreground));
    }
    
    .btn-destructive:hover {
      opacity: 0.9;
    }
    
    .btn-ghost {
      background-color: transparent;
      color: hsl(var(--foreground));
    }
    
    .btn-ghost:hover {
      background-color: hsl(var(--accent));
      color: hsl(var(--accent-foreground));
    }
    
    .btn-icon {
      padding: 0.5rem;
    }
    
    .card {
      background-color: hsl(var(--card));
      color: hsl(var(--card-foreground));
      border-radius: var(--radius);
      box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
      overflow: hidden;
    }
    
    .input {
      display: flex;
      height: 2.5rem;
      width: 100%;
      border-radius: var(--radius);
      border: 1px solid hsl(var(--input));
      background-color: transparent;
      padding: 0.5rem 0.75rem;
      font-size: 0.875rem;
      line-height: 1.25rem;
      transition: border-color 0.2s ease;
    }
    
    .input:focus {
      outline: none;
      border-color: hsl(var(--ring));
      box-shadow: 0 0 0 2px rgba(var(--ring), 0.3);
    }
    
    .textarea {
      min-height: 5rem;
    }
    
    .select {
      height: 2.5rem;
      width: 100%;
      border-radius: var(--radius);
      border: 1px solid hsl(var(--input));
      background-color: transparent;
      padding: 0.5rem 0.75rem;
      font-size: 0.875rem;
      line-height: 1.25rem;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m6 9 6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 0.75rem center;
      background-size: 1rem;
    }
    
    .select:focus {
      outline: none;
      border-color: hsl(var(--ring));
      box-shadow: 0 0 0 2px rgba(var(--ring), 0.3);
    }
    
    .label {
      font-size: 0.875rem;
      font-weight: 500;
      line-height: 1.25rem;
      margin-bottom: 0.5rem;
      display: block;
    }
    
    .badge {
      display: inline-flex;
      align-items: center;
      border-radius: 9999px;
      font-weight: 500;
      font-size: 0.75rem;
      line-height: 1rem;
      padding: 0.125rem 0.5rem;
      height: 1.25rem;
    }
    
    .badge-primary {
      background-color: hsl(var(--primary));
      color: hsl(var(--primary-foreground));
    }
    
    .badge-secondary {
      background-color: hsl(var(--secondary));
      color: hsl(var(--secondary-foreground));
    }
    
    .skeleton {
      background-color: hsl(var(--muted));
      border-radius: var(--radius);
      animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }
    
    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.5;
      }
    }
    
    .ph {
      display: inline-block;
      width: 1em;
      height: 1em;
      vertical-align: -0.125em;
    }
    
    /* Responsive utils */
    .mobile-only {
      display: block;
    }
    
    .desktop-only {
      display: none;
    }
    
    @media (min-width: 768px) {
      .mobile-only {
        display: none;
      }
      
      .desktop-only {
        display: block;
      }
    }
    
    /* Toast notification */
    .toast-container {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      z-index: 50;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .toast {
      display: flex;
      max-width: 350px;
      padding: 1rem;
      border-radius: var(--radius);
      box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      animation: slideIn 0.3s ease-out;
    }
    
    .toast-success {
      background-color: #10b981;
      color: white;
    }
    
    .toast-error {
      background-color: hsl(var(--destructive));
      color: white;
    }
    
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }
    
    /* Drawer */
    .drawer {
      position: fixed;
      top: 0;
      left: 0;
      height: 100%;
      width: 100%;
      max-width: 320px;
      background-color: hsl(var(--background));
      box-shadow: 4px 0 8px rgba(0, 0, 0, 0.1);
      transform: translateX(-100%);
      transition: transform 0.3s ease-in-out;
      z-index: 40;
    }
    
    .drawer.open {
      transform: translateX(0);
    }
    
    .drawer-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.4);
      z-index: 30;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease-in-out;
    }
    
    .drawer-overlay.open {
      opacity: 1;
      visibility: visible;
    }
    
    /* Dialog */
    .dialog-overlay {
      position: fixed;
      inset: 0;
      background-color: rgba(0, 0, 0, 0.4);
      z-index: 40;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease-in-out;
    }
    
    .dialog-overlay.open {
      opacity: 1;
      visibility: visible;
    }
    
    .dialog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      background-color: hsl(var(--background));
      border-radius: var(--radius);
      box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
      width: calc(100% - 2rem);
      max-width: 500px;
      max-height: calc(100vh - 2rem);
      overflow-y: auto;
      z-index: 50;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease-in-out;
    }
    
    .dialog.open {
      opacity: 1;
      visibility: visible;
      transform: translate(-50%, -50%) scale(1);
    }
    
    /* Loading spinner */
    .spinner {
      width: 1.5rem;
      height: 1.5rem;
      border-radius: 50%;
      border: 2px solid currentColor;
      border-right-color: transparent;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
    
    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 1px solid hsl(var(--border));
      margin-bottom: 1rem;
    }
    
    .tab {
      padding: 0.75rem 1rem;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      font-weight: 500;
      transition: all 0.2s ease;
    }
    
    .tab:hover {
      color: hsl(var(--primary));
    }
    
    .tab.active {
      color: hsl(var(--primary));
      border-bottom-color: hsl(var(--primary));
    }
    
    /* Tables */
    .table-container {
      width: 100%;
      overflow-x: auto;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
    }
    
    th {
      text-align: left;
      padding: 0.75rem 1rem;
      font-weight: 500;
      border-bottom: 1px solid hsl(var(--border));
      color: hsl(var(--muted-foreground));
      font-size: 0.875rem;
    }
    
    td {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid hsl(var(--border));
      font-size: 0.875rem;
    }
    
    tr:last-child td {
      border-bottom: none;
    }
    
    /* Avatar */
    .avatar {
      position: relative;
      border-radius: 50%;
      overflow: hidden;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background-color: hsl(var(--muted));
    }
    
    .avatar-sm {
      width: 2rem;
      height: 2rem;
    }
    
    .avatar-md {
      width: 3rem;
      height: 3rem;
    }
    
    .avatar-lg {
      width: 4rem;
      height: 4rem;
    }
    
    .avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    /* Dropdown */
    .dropdown {
      position: relative;
    }
    
    .dropdown-content {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 0.25rem;
      min-width: 10rem;
      background-color: hsl(var(--popover));
      border-radius: var(--radius);
      border: 1px solid hsl(var(--border));
      box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      opacity: 0;
      transform: translateY(-8px);
      pointer-events: none;
      transition: all 0.2s ease-in-out;
      z-index: 20;
    }
    
    .dropdown-content.open {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }
    
    .dropdown-item {
      display: flex;
      align-items: center;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    
    .dropdown-item:hover {
      background-color: hsl(var(--accent));
    }
    
    /* Collapsible */
    .collapsible-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-in-out;
    }
    
    .collapsible-content.open {
      max-height: 1000px;
    }
  </style>
</head>
<body>
  <!-- Toast Container -->
  <div class="toast-container" id="toastContainer"></div>
  
  <!-- Mobile Menu Drawer -->
  <div class="drawer" id="mobileMenu">
    <div class="p-4 flex items-center justify-between">
      <span class="text-lg font-semibold">Anime API Admin</span>
      <button class="btn btn-ghost btn-icon" id="closeDrawer">
        <i class="ph ph-x"></i>
      </button>
    </div>
    <div class="px-4 py-2">
      <div class="mb-4">
        <button class="btn btn-primary w-full justify-start" id="mobileBtnAddAnime">
          <i class="ph ph-plus mr-2"></i> Add Anime
        </button>
      </div>
      <div class="space-y-1">
        <button class="w-full text-left p-2 rounded hover:bg-blue-50 dark:hover:bg-gray-800 flex items-center mobile-nav-item active" data-page="dashboard">
          <i class="ph ph-chart-pie mr-2"></i> Dashboard
        </button>
        <button class="w-full text-left p-2 rounded hover:bg-blue-50 dark:hover:bg-gray-800 flex items-center mobile-nav-item" data-page="anime">
          <i class="ph ph-television mr-2"></i> Anime
        </button>
        <button class="w-full text-left p-2 rounded hover:bg-blue-50 dark:hover:bg-gray-800 flex items-center mobile-nav-item" data-page="episodes">
          <i class="ph ph-film-strip mr-2"></i> Episodes
        </button>
        <button class="w-full text-left p-2 rounded hover:bg-blue-50 dark:hover:bg-gray-800 flex items-center mobile-nav-item" data-page="scheduled">
          <i class="ph ph-calendar mr-2"></i> Scheduled
        </button>
        <button class="w-full text-left p-2 rounded hover:bg-blue-50 dark:hover:bg-gray-800 flex items-center mobile-nav-item" data-page="settings">
          <i class="ph ph-gear mr-2"></i> Settings
        </button>
      </div>
    </div>
  </div>
  <div class="drawer-overlay" id="drawerOverlay"></div>
  
  <!-- Main Container -->
  <div class="min-h-screen flex flex-col">
    <!-- Header -->
    <header class="sticky top-0 z-10 bg-white dark:bg-gray-900 border-b">
      <div class="container mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex items-center justify-between h-16">
          <!-- Left side -->
          <div class="flex items-center">
            <button class="mr-4 btn btn-ghost btn-icon mobile-only" id="openDrawer">
              <i class="ph ph-list"></i>
            </button>
            <div class="desktop-only font-semibold text-lg">Anime API Admin</div>
          </div>
          
          <!-- Right side -->
          <div class="flex items-center space-x-4">
            <div class="desktop-only">
              <button class="btn btn-primary" id="desktopBtnAddAnime">
                <i class="ph ph-plus mr-2"></i> Add Anime
              </button>
            </div>
            <div class="relative">
              <button class="btn btn-ghost btn-icon" id="themeToggle">
                <i class="ph ph-sun"></i>
              </button>
            </div>
            <div class="dropdown">
              <button class="btn btn-ghost btn-icon" id="userDropdownBtn">
                <i class="ph ph-user-circle"></i>
              </button>
              <div class="dropdown-content" id="userDropdown">
                <div class="p-2 border-b">
                  <div class="font-medium">Admin User</div>
                  <div class="text-sm text-gray-500">admin@example.com</div>
                </div>
                <div class="py-1">
                  <button class="dropdown-item">
                    <i class="ph ph-user-gear mr-2"></i> Account
                  </button>
                  <button class="dropdown-item">
                    <i class="ph ph-faders-horizontal mr-2"></i> Preferences
                  </button>
                  <button class="dropdown-item">
                    <i class="ph ph-sign-out mr-2"></i> Logout
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </header>
    
    <!-- Desktop Sidebar and Main Content -->
    <div class="flex-1 flex">
      <!-- Sidebar (desktop only) -->
      <aside class="desktop-only w-56 border-r hidden md:block">
        <div class="p-4 space-y-4">
          <div class="space-y-1">
            <button class="w-full text-left p-2 rounded hover:bg-blue-50 dark:hover:bg-gray-800 flex items-center sidebar-nav-item active" data-page="dashboard">
              <i class="ph ph-chart-pie mr-2"></i> Dashboard
            </button>
            <button class="w-full text-left p-2 rounded hover:bg-blue-50 dark:hover:bg-gray-800 flex items-center sidebar-nav-item" data-page="anime">
              <i class="ph ph-television mr-2"></i> Anime
            </button>
            <button class="w-full text-left p-2 rounded hover:bg-blue-50 dark:hover:bg-gray-800 flex items-center sidebar-nav-item" data-page="episodes">
              <i class="ph ph-film-strip mr-2"></i> Episodes
            </button>
            <button class="w-full text-left p-2 rounded hover:bg-blue-50 dark:hover:bg-gray-800 flex items-center sidebar-nav-item" data-page="scheduled">
              <i class="ph ph-calendar mr-2"></i> Scheduled
            </button>
            <button class="w-full text-left p-2 rounded hover:bg-blue-50 dark:hover:bg-gray-800 flex items-center sidebar-nav-item" data-page="settings">
              <i class="ph ph-gear mr-2"></i> Settings
            </button>
          </div>
        </div>
      </aside>
      
      <!-- Main Content -->
      <main class="flex-1 overflow-y-auto p-4 sm:p-6 lg:p-8">
        <div id="pageContent">
          <!-- Dashboard Page -->
          <div id="dashboardPage" class="page-content active">
            <div class="mb-6">
              <h1 class="text-2xl font-bold">Dashboard</h1>
              <p class="text-gray-500">Welcome to the Anime API Admin Dashboard</p>
            </div>
            
            <!-- Stats Cards -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
              <div class="card p-4">
                <div class="text-sm font-medium text-gray-500 mb-1">Total Anime</div>
                <div class="text-2xl font-bold" id="totalAnimeCount">...</div>
                <div class="text-green-500 text-sm flex items-center mt-2">
                  <i class="ph ph-trend-up mr-1"></i> 
                  <span id="animeGrowth">...</span>
                </div>
              </div>
              
              <div class="card p-4">
                <div class="text-sm font-medium text-gray-500 mb-1">Total Episodes</div>
                <div class="text-2xl font-bold" id="totalEpisodesCount">...</div>
                <div class="text-green-500 text-sm flex items-center mt-2">
                  <i class="ph ph-trend-up mr-1"></i> 
                  <span id="episodesGrowth">...</span>
                </div>
              </div>
              
              <div class="card p-4">
                <div class="text-sm font-medium text-gray-500 mb-1">Scheduled</div>
                <div class="text-2xl font-bold" id="scheduledCount">...</div>
                <div class="text-blue-500 text-sm flex items-center mt-2">
                  <i class="ph ph-calendar mr-1"></i> 
                  <span id="nextScheduled">...</span>
                </div>
              </div>
              
              <div class="card p-4">
                <div class="text-sm font-medium text-gray-500 mb-1">Tagalog Dubbed</div>
                <div class="text-2xl font-bold" id="tagalogDubbedCount">...</div>
                <div class="text-gray-500 text-sm flex items-center mt-2">
                  <i class="ph ph-globe mr-1"></i> 
                  <span id="tagalogPercentage">...</span>
                </div>
              </div>
            </div>
            
            <!-- Recent Activity and Upcoming Releases -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
              <!-- Recent Activity -->
              <div class="card">
                <div class="p-4 border-b flex justify-between items-center">
                  <h2 class="font-semibold">Recent Activity</h2>
                  <button class="btn btn-ghost btn-sm">View All</button>
                </div>
                <div class="p-4">
                  <div class="space-y-4" id="recentActivityContainer">
                    <div class="skeleton h-12 w-full"></div>
                    <div class="skeleton h-12 w-full"></div>
                    <div class="skeleton h-12 w-full"></div>
                    <div class="skeleton h-12 w-full"></div>
                  </div>
                </div>
              </div>
              
              <!-- Upcoming Releases -->
              <div class="card">
                <div class="p-4 border-b flex justify-between items-center">
                  <h2 class="font-semibold">Upcoming Releases</h2>
                  <button class="btn btn-ghost btn-sm">View All</button>
                </div>
                <div class="p-4">
                  <div class="space-y-4" id="upcomingReleasesContainer">
                    <div class="skeleton h-16 w-full"></div>
                    <div class="skeleton h-16 w-full"></div>
                    <div class="skeleton h-16 w-full"></div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Quick Actions -->
            <div class="card mb-8">
              <div class="p-4 border-b">
                <h2 class="font-semibold">Quick Actions</h2>
              </div>
              <div class="p-4 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">
                <button class="btn btn-primary w-full" id="quickAddAnimeBtn">
                  <i class="ph ph-plus-circle mr-2"></i> Add Anime
                </button>
                <button class="btn btn-secondary w-full" id="quickAddEpisodeBtn">
                  <i class="ph ph-film-strip mr-2"></i> Add Episode
                </button>
                <button class="btn btn-secondary w-full" id="quickScheduleReleaseBtn">
                  <i class="ph ph-calendar-plus mr-2"></i> Schedule Release
                </button>
                <button class="btn btn-secondary w-full" id="quickExportDataBtn">
                  <i class="ph ph-download mr-2"></i> Export Data
                </button>
              </div>
            </div>
          </div>
          
          <!-- Anime Page -->
          <div id="animePage" class="page-content hidden">
            <div class="mb-6 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
              <div>
                <h1 class="text-2xl font-bold">Anime Library</h1>
                <p class="text-gray-500">Manage your anime collection</p>
              </div>
              <div class="flex gap-2">
                <div class="relative flex-grow max-w-md">
                  <i class="ph ph-magnifying-glass absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400"></i>
                  <input type="text" id="animeSearch" placeholder="Search anime..." class="input pl-10 w-full">
                </div>
                <button class="btn btn-primary" id="animeBtnAdd">
                  <i class="ph ph-plus mr-2"></i> Add Anime
                </button>
              </div>
            </div>
            
            <!-- Filter and Sort Controls -->
            <div class="card mb-6">
              <div class="p-4 flex flex-wrap gap-4">
                <div class="flex-1 min-w-[200px]">
                  <label class="label" for="animeFilter">Filter by</label>
                  <select id="animeFilter" class="select">
                    <option value="all">All Anime</option>
                    <option value="tagalog">Tagalog Dubbed</option>
                    <option value="recent">Recently Added</option>
                  </select>
                </div>
                <div class="flex-1 min-w-[200px]">
                  <label class="label" for="animeSort">Sort by</label>
                  <select id="animeSort" class="select">
                    <option value="title">Title (A-Z)</option>
                    <option value="dateAdded">Date Added</option>
                    <option value="popularity">Popularity</option>
                    <option value="rating">Rating</option>
                  </select>
                </div>
                <div class="flex-1 min-w-[200px]">
                  <label class="label" for="animeView">View as</label>
                  <div class="flex border rounded-md overflow-hidden">
                    <button class="flex-1 py-2 px-3 flex justify-center items-center bg-blue-50 dark:bg-gray-800" id="gridViewBtn">
                      <i class="ph ph-grid-four"></i>
                    </button>
                    <button class="flex-1 py-2 px-3 flex justify-center items-center" id="listViewBtn">
                      <i class="ph ph-list"></i>
                    </button>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Anime Grid -->
            <div id="animeGridContainer" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6 mb-8">
              <!-- Anime Card Skeleton -->
              <div class="card skeleton-card">
                <div class="skeleton h-48"></div>
                <div class="p-4">
                  <div class="skeleton h-6 w-3/4 mb-2"></div>
                  <div class="skeleton h-4 w-1/2 mb-4"></div>
                  <div class="skeleton h-10 w-full"></div>
                </div>
              </div>
              <div class="card skeleton-card">
                <div class="skeleton h-48"></div>
                <div class="p-4">
                  <div class="skeleton h-6 w-3/4 mb-2"></div>
                  <div class="skeleton h-4 w-1/2 mb-4"></div>
                  <div class="skeleton h-10 w-full"></div>
                </div>
              </div>
              <div class="card skeleton-card">
                <div class="skeleton h-48"></div>
                <div class="p-4">
                  <div class="skeleton h-6 w-3/4 mb-2"></div>
                  <div class="skeleton h-4 w-1/2 mb-4"></div>
                  <div class="skeleton h-10 w-full"></div>
                </div>
              </div>
              <div class="card skeleton-card">
                <div class="skeleton h-48"></div>
                <div class="p-4">
                  <div class="skeleton h-6 w-3/4 mb-2"></div>
                  <div class="skeleton h-4 w-1/2 mb-4"></div>
                  <div class="skeleton h-10 w-full"></div>
                </div>
              </div>
            </div>
            
            <!-- Anime List View (Hidden by default) -->
            <div id="animeListContainer" class="card table-container hidden">
              <table class="w-full">
                <thead>
                  <tr>
                    <th>Title</th>
                    <th>Episodes</th>
                    <th>Rating</th>
                    <th>Status</th>
                    <th>Tagalog Dub</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody id="animeListBody">
                  <!-- List items will be inserted here by JS -->
                  <tr>
                    <td colspan="6" class="text-center py-8 text-gray-500">Loading anime list...</td>
                  </tr>
                </tbody>
              </table>
            </div>
            
            <!-- Pagination -->
            <div class="flex justify-between items-center mt-6">
              <p class="text-sm text-gray-500" id="animePaginationInfo">Showing 0 of 0 entries</p>
              <div class="flex gap-2">
                <button class="btn btn-ghost btn-sm" id="prevPageBtn" disabled>
                  <i class="ph ph-caret-left mr-1"></i> Previous
                </button>
                <button class="btn btn-ghost btn-sm" id="nextPageBtn" disabled>
                  Next <i class="ph ph-caret-right ml-1"></i>
                </button>
              </div>
            </div>
          </div>
          
          <!-- Episodes Page -->
          <div id="episodesPage" class="page-content hidden">
            <div class="mb-6 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
              <div>
                <h1 class="text-2xl font-bold">Episode Manager</h1>
                <p class="text-gray-500">Manage anime episodes</p>
              </div>
              <div class="flex gap-2">
                <div class="relative flex-grow max-w-md">
                  <i class="ph ph-magnifying-glass absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400"></i>
                  <input type="text" id="episodeSearch" placeholder="Search episodes..." class="input pl-10 w-full">
                </div>
                <button class="btn btn-primary" id="episodeBtnAdd">
                  <i class="ph ph-plus mr-2"></i> Add Episode
                </button>
              </div>
            </div>
            
            <!-- Filter Controls -->
            <div class="card mb-6">
              <div class="p-4 flex flex-wrap gap-4">
                <div class="flex-1 min-w-[200px]">
                  <label class="label" for="episodeAnimeFilter">Anime</label>
                  <select id="episodeAnimeFilter" class="select">
                    <option value="all">All Anime</option>
                    <!-- Options will be filled by JavaScript -->
                  </select>
                </div>
                <div class="flex-1 min-w-[200px]">
                  <label class="label" for="episodeLanguageFilter">Language</label>
                  <select id="episodeLanguageFilter" class="select">
                    <option value="all">All Languages</option>
                    <option value="subbed">Subbed</option>
                    <option value="tagalog">Tagalog Dubbed</option>
                  </select>
                </div>
                <div class="flex-1 min-w-[200px]">
                  <label class="label" for="episodeSortOrder">Sort by</label>
                  <select id="episodeSortOrder" class="select">
                    <option value="newest">Newest First</option>
                    <option value="oldest">Oldest First</option>
                    <option value="episode_asc">Episode Number (Asc)</option>
                    <option value="episode_desc">Episode Number (Desc)</option>
                  </select>
                </div>
              </div>
            </div>
            
            <!-- Episodes Table -->
            <div class="card table-container mb-6">
              <table class="w-full">
                <thead>
                  <tr>
                    <th>Anime</th>
                    <th>Episode</th>
                    <th>Title</th>
                    <th>Language</th>
                    <th>Date Added</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody id="episodesTableBody">
                  <!-- Episode rows will be inserted here by JS -->
                  <tr>
                    <td colspan="6" class="text-center py-8 text-gray-500">Loading episodes...</td>
                  </tr>
                </tbody>
              </table>
            </div>
            
            <!-- Pagination -->
            <div class="flex justify-between items-center">
              <p class="text-sm text-gray-500" id="episodePaginationInfo">Showing 0 of 0 entries</p>
              <div class="flex gap-2">
                <button class="btn btn-ghost btn-sm" id="episodePrevPageBtn" disabled>
                  <i class="ph ph-caret-left mr-1"></i> Previous
                </button>
                <button class="btn btn-ghost btn-sm" id="episodeNextPageBtn" disabled>
                  Next <i class="ph ph-caret-right ml-1"></i>
                </button>
              </div>
            </div>
          </div>
          
          <!-- Scheduled Page -->
          <div id="scheduledPage" class="page-content hidden">
            <div class="mb-6 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
              <div>
                <h1 class="text-2xl font-bold">Scheduled Releases</h1>
                <p class="text-gray-500">Manage upcoming anime releases</p>
              </div>
              <button class="btn btn-primary" id="scheduledBtnAdd">
                <i class="ph ph-plus mr-2"></i> Schedule Release
              </button>
            </div>
            
            <!-- Calendar View -->
            <div class="card mb-6">
              <div class="p-4 border-b">
                <div class="flex items-center justify-between">
                  <h2 class="font-semibold">Upcoming Releases</h2>
                  <div class="flex items-center space-x-2">
                    <button class="btn btn-ghost btn-sm btn-icon" id="prevMonthBtn">
                      <i class="ph ph-caret-left"></i>
                    </button>
                    <span class="font-medium" id="currentMonthYear">April 2025</span>
                    <button class="btn btn-ghost btn-sm btn-icon" id="nextMonthBtn">
                      <i class="ph ph-caret-right"></i>
                    </button>
                  </div>
                </div>
              </div>
              <div class="p-4 overflow-x-auto">
                <div id="calendarContainer" class="min-w-[768px]">
                  <!-- Calendar will be generated by JavaScript -->
                  <div class="skeleton h-80 w-full"></div>
                </div>
              </div>
            </div>
            
            <!-- Scheduled List -->
            <div class="card">
              <div class="p-4 border-b">
                <h2 class="font-semibold">Scheduled List</h2>
              </div>
              <div class="table-container">
                <table class="w-full">
                  <thead>
                    <tr>
                      <th>Anime</th>
                      <th>Release Date</th>
                      <th>Language</th>
                      <th>Notes</th>
                      <th>Actions</th>
                    </tr>
                  </thead>
                  <tbody id="scheduledTableBody">
                    <!-- Scheduled items will be inserted here by JS -->
                    <tr>
                      <td colspan="5" class="text-center py-8 text-gray-500">Loading scheduled releases...</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
          
          <!-- Settings Page -->
          <div id="settingsPage" class="page-content hidden">
            <div class="mb-6">
              <h1 class="text-2xl font-bold">Settings</h1>
              <p class="text-gray-500">Manage API settings and data</p>
            </div>
            
            <!-- Settings Tabs -->
            <div class="tabs mb-6">
              <button class="tab active" data-tab="general">General</button>
              <button class="tab" data-tab="backup">Backup & Restore</button>
              <button class="tab" data-tab="api">API</button>
              <button class="tab" data-tab="advanced">Advanced</button>
            </div>
            
            <!-- General Settings -->
            <div class="tab-content active" id="generalTab">
              <div class="card mb-6">
                <div class="p-4 border-b">
                  <h2 class="font-semibold">Display Settings</h2>
                </div>
                <div class="p-4 space-y-4">
                  <div>
                    <label class="label" for="themeSelect">Theme</label>
                    <select id="themeSelect" class="select">
                      <option value="light">Light</option>
                      <option value="dark">Dark</option>
                      <option value="system">System</option>
                    </select>
                  </div>
                  <div class="flex items-center">
                    <input type="checkbox" id="enableAnimations" class="mr-2">
                    <label for="enableAnimations">Enable animations</label>
                  </div>
                </div>
              </div>
              
              <div class="card mb-6">
                <div class="p-4 border-b">
                  <h2 class="font-semibold">Content Settings</h2>
                </div>
                <div class="p-4 space-y-4">
                  <div>
                    <label class="label" for="itemsPerPage">Items per page</label>
                    <select id="itemsPerPage" class="select">
                      <option value="10">10</option>
                      <option value="20">20</option>
                      <option value="50">50</option>
                      <option value="100">100</option>
                    </select>
                  </div>
                  <div>
                    <label class="label" for="defaultLanguage">Default language for new episodes</label>
                    <select id="defaultLanguage" class="select">
                      <option value="subbed">Subbed</option>
                      <option value="tagalog">Tagalog Dubbed</option>
                    </select>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Backup & Restore Tab -->
            <div class="tab-content hidden" id="backupTab">
              <div class="card mb-6">
                <div class="p-4 border-b">
                  <h2 class="font-semibold">Backup Data</h2>
                </div>
                <div class="p-4 space-y-4">
                  <p>Create a backup of all your anime data. This includes anime, episodes, and scheduled releases.</p>
                  <button class="btn btn-primary" id="backupBtn">
                    <i class="ph ph-download mr-2"></i> Download Backup
                  </button>
                </div>
              </div>
              
              <div class="card mb-6">
                <div class="p-4 border-b">
                  <h2 class="font-semibold">Restore Data</h2>
                </div>
                <div class="p-4 space-y-4">
                  <p>Restore data from a backup file. This will replace all current data with the backup content.</p>
                  <div class="flex flex-col sm:flex-row gap-2">
                    <input type="file" id="restoreFileInput" accept=".json" class="hidden">
                    <button class="btn btn-secondary" id="chooseFileBtn">
                      <i class="ph ph-file mr-2"></i> Choose Backup File
                    </button>
                    <button class="btn btn-primary" id="restoreBtn" disabled>
                      <i class="ph ph-upload mr-2"></i> Restore Backup
                    </button>
                  </div>
                  <div class="text-sm text-gray-500 mt-2" id="selectedFileInfo">No file selected</div>
                </div>
              </div>
              
              <div class="card">
                <div class="p-4 border-b">
                  <h2 class="font-semibold">Auto Backup</h2>
                </div>
                <div class="p-4 space-y-4">
                  <p>Configure automatic backup settings.</p>
                  <div>
                    <label class="label" for="autoBackupFrequency">Backup frequency</label>
                    <select id="autoBackupFrequency" class="select">
                      <option value="daily">Daily</option>
                      <option value="weekly">Weekly</option>
                      <option value="monthly">Monthly</option>
                      <option value="never">Never</option>
                    </select>
                  </div>
                  <div class="flex items-center">
                    <input type="checkbox" id="autoBackupEnabled" class="mr-2">
                    <label for="autoBackupEnabled">Enable automatic backups</label>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- API Tab -->
            <div class="tab-content hidden" id="apiTab">
              <div class="card mb-6">
                <div class="p-4 border-b">
                  <h2 class="font-semibold">API Information</h2>
                </div>
                <div class="p-4 space-y-4">
                  <div>
                    <label class="label">API Base URL</label>
                    <div class="flex">
                      <input type="text" readonly value="/api" class="input bg-gray-50 flex-grow" id="apiUrlDisplay">
                      <button class="btn btn-ghost btn-icon ml-2" id="copyApiUrlBtn">
                        <i class="ph ph-copy"></i>
                      </button>
                    </div>
                  </div>
                  <div>
                    <label class="label">API Status</label>
                    <div class="flex items-center">
                      <div class="w-3 h-3 rounded-full bg-green-500 mr-2"></div>
                      <span>Operational</span>
                    </div>
                  </div>
                </div>
              </div>
              
              <div class="card mb-6">
                <div class="p-4 border-b">
                  <h2 class="font-semibold">API Documentation</h2>
                </div>
                <div class="p-4 space-y-4">
                  <p>Use the following endpoints to access your anime data:</p>
                  
                  <div class="space-y-2">
                    <div class="card bg-gray-50 dark:bg-gray-800 p-3">
                      <div class="flex items-center justify-between">
                        <div>
                          <span class="badge bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200">GET</span>
                          <span class="ml-2 font-mono text-sm">/api/anime</span>
                        </div>
                        <button class="btn btn-ghost btn-icon btn-sm">
                          <i class="ph ph-copy"></i>
                        </button>
                      </div>
                      <p class="text-sm text-gray-500 mt-1">Get all anime in your library</p>
                    </div>
                    
                    <div class="card bg-gray-50 dark:bg-gray-800 p-3">
                      <div class="flex items-center justify-between">
                        <div>
                          <span class="badge bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200">GET</span>
                          <span class="ml-2 font-mono text-sm">/api/anime/:id</span>
                        </div>
                        <button class="btn btn-ghost btn-icon btn-sm">
                          <i class="ph ph-copy"></i>
                        </button>
                      </div>
                      <p class="text-sm text-gray-500 mt-1">Get a specific anime by ID</p>
                    </div>
                    
                    <div class="card bg-gray-50 dark:bg-gray-800 p-3">
                      <div class="flex items-center justify-between">
                        <div>
                          <span class="badge bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200">GET</span>
                          <span class="ml-2 font-mono text-sm">/api/anime/:id/episodes</span>
                        </div>
                        <button class="btn btn-ghost btn-icon btn-sm">
                          <i class="ph ph-copy"></i>
                        </button>
                      </div>
                      <p class="text-sm text-gray-500 mt-1">Get all episodes for a specific anime</p>
                    </div>
                  </div>
                  
                  <button class="btn btn-secondary">
                    <i class="ph ph-book-open-text mr-2"></i> View Full Documentation
                  </button>
                </div>
              </div>
            </div>
            
            <!-- Advanced Tab -->
            <div class="tab-content hidden" id="advancedTab">
              <div class="card mb-6">
                <div class="p-4 border-b">
                  <h2 class="font-semibold">Advanced Settings</h2>
                </div>
                <div class="p-4 space-y-4">
                  <div>
                    <label class="label" for="cacheTimeout">Cache Timeout (minutes)</label>
                    <input type="number" id="cacheTimeout" class="input" value="60" min="1" max="1440">
                  </div>
                  <div>
                    <label class="label" for="logLevel">Log Level</label>
                    <select id="logLevel" class="select">
                      <option value="error">Error</option>
                      <option value="warning">Warning</option>
                      <option value="info">Info</option>
                      <option value="debug">Debug</option>
                    </select>
                  </div>
                  <div class="flex items-center">
                    <input type="checkbox" id="enableDevMode" class="mr-2">
                    <label for="enableDevMode">Enable developer mode</label>
                  </div>
                </div>
              </div>
              
              <div class="card mb-6">
                <div class="p-4 border-b">
                  <h2 class="font-semibold">Danger Zone</h2>
                </div>
                <div class="p-4 space-y-4">
                  <p class="text-sm text-gray-500">These actions are potentially destructive and cannot be undone. Please make sure you have a backup before proceeding.</p>
                  
                  <button class="btn btn-secondary w-full sm:w-auto" id="clearCacheBtn">
                    <i class="ph ph-trash mr-2"></i> Clear Cache
                  </button>
                  
                  <button class="btn btn-destructive w-full sm:w-auto" id="resetDataBtn">
                    <i class="ph ph-warning-circle mr-2"></i> Reset All Data
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>
  </div>
  
  <!-- Add Anime Dialog -->
  <div class="dialog-overlay" id="addAnimeOverlay"></div>
  <div class="dialog" id="addAnimeDialog">
    <div class="p-4 border-b">
      <h2 class="font-semibold">Add New Anime</h2>
    </div>
    <div class="p-4">
      <div class="mb-4">
        <label class="label" for="animeSearchInput">Search Anime</label>
        <div class="relative">
          <input type="text" id="animeSearchInput" class="input pr-10" placeholder="Enter anime title...">
          <button class="absolute right-2 top-1/2 transform -translate-y-1/2 btn btn-ghost btn-icon" id="animeSearchBtn">
            <i class="ph ph-magnifying-glass"></i>
          </button>
        </div>
      </div>
      
      <div id="animeSearchResults" class="hidden mb-4">
        <label class="label">Search Results</label>
        <div class="max-h-[300px] overflow-y-auto border rounded-md" id="animeResultsList">
          <!-- Results will be populated here -->
        </div>
      </div>
      
      <div id="selectedAnimeInfo" class="hidden mb-4">
        <label class="label">Selected Anime</label>
        <div class="flex gap-4 p-4 border rounded-md">
          <div class="w-24 h-32 skeleton" id="selectedAnimeImage"></div>
          <div class="flex-1">
            <h3 class="font-medium mb-1" id="selectedAnimeTitle">Anime Title</h3>
            <p class="text-sm text-gray-500 mb-2" id="selectedAnimeDetails">Episodes: 12 | Rating: 8.5</p>
            <div class="mb-2">
              <div class="flex items-center">
                <input type="checkbox" id="hasTagalogDubCheckbox" class="mr-2">
                <label for="hasTagalogDubCheckbox" class="text-sm">Has Tagalog Dub</label>
              </div>
            </div>
            <p class="text-sm text-gray-500" id="selectedAnimeDescription">Description will appear here...</p>
          </div>
        </div>
      </div>
    </div>
    <div class="p-4 border-t flex justify-end gap-2">
      <button class="btn btn-ghost" id="cancelAddAnimeBtn">Cancel</button>
      <button class="btn btn-primary" id="confirmAddAnimeBtn" disabled>Add to Library</button>
    </div>
  </div>
  
  <!-- Add Episode Dialog -->
  <div class="dialog-overlay" id="addEpisodeOverlay"></div>
  <div class="dialog" id="addEpisodeDialog">
    <div class="p-4 border-b">
      <h2 class="font-semibold">Add New Episode</h2>
    </div>
    <div class="p-4">
      <div class="mb-4">
        <label class="label" for="episodeAnimeSelect">Anime</label>
        <select id="episodeAnimeSelect" class="select">
          <option value="">Select an anime</option>
          <!-- Options will be filled dynamically -->
        </select>
      </div>
      
      <div class="mb-4">
        <label class="label" for="episodeNumber">Episode Number</label>
        <input type="number" id="episodeNumber" class="input" min="1" step="1">
      </div>
      
      <div class="mb-4">
        <label class="label" for="episodeTitle">Episode Title (Optional)</label>
        <input type="text" id="episodeTitle" class="input" placeholder="e.g., The Beginning">
      </div>
      
      <div class="mb-4">
        <label class="label" for="episodeiFrameSrc">Server 1 URL (iFrame Source)</label>
        <input type="text" id="episodeiFrameSrc" class="input" placeholder="https://example.com/embed/...">
      </div>
      
      <div class="mb-4">
        <label class="label" for="episodeServer2Url">Server 2 URL (Optional)</label>
        <input type="text" id="episodeServer2Url" class="input" placeholder="https://backup-server.com/video/...">
      </div>
      
      <div class="mb-4">
        <div class="flex items-center">
          <input type="checkbox" id="episodeHasTagalogDub" class="mr-2">
          <label for="episodeHasTagalogDub">Tagalog Dubbed</label>
        </div>
      </div>
    </div>
    <div class="p-4 border-t flex justify-end gap-2">
      <button class="btn btn-ghost" id="cancelAddEpisodeBtn">Cancel</button>
      <button class="btn btn-primary" id="confirmAddEpisodeBtn">Add Episode</button>
    </div>
  </div>
  
  <!-- Schedule Release Dialog -->
  <div class="dialog-overlay" id="scheduleReleaseOverlay"></div>
  <div class="dialog" id="scheduleReleaseDialog">
    <div class="p-4 border-b">
      <h2 class="font-semibold">Schedule Anime Release</h2>
    </div>
    <div class="p-4">
      <div class="mb-4">
        <label class="label" for="scheduleAnimeSelect">Anime</label>
        <select id="scheduleAnimeSelect" class="select">
          <option value="">Select an anime</option>
          <!-- Options will be filled dynamically -->
        </select>
      </div>
      
      <div class="mb-4">
        <label class="label" for="scheduleReleaseDate">Release Date</label>
        <input type="date" id="scheduleReleaseDate" class="input">
      </div>
      
      <div class="mb-4">
        <label class="label" for="scheduleNotes">Notes (Optional)</label>
        <textarea id="scheduleNotes" class="input textarea" placeholder="Additional information about this release"></textarea>
      </div>
      
      <div class="mb-4">
        <div class="flex items-center">
          <input type="checkbox" id="scheduleHasTagalogDub" class="mr-2">
          <label for="scheduleHasTagalogDub">Will have Tagalog Dub</label>
        </div>
      </div>
    </div>
    <div class="p-4 border-t flex justify-end gap-2">
      <button class="btn btn-ghost" id="cancelScheduleBtn">Cancel</button>
      <button class="btn btn-primary" id="confirmScheduleBtn">Schedule Release</button>
    </div>
  </div>
  
  <!-- Delete Confirmation Dialog -->
  <div class="dialog-overlay" id="deleteConfirmOverlay"></div>
  <div class="dialog" id="deleteConfirmDialog">
    <div class="p-4 border-b">
      <h2 class="font-semibold">Confirm Deletion</h2>
    </div>
    <div class="p-4">
      <p id="deleteConfirmMessage">Are you sure you want to delete this item? This action cannot be undone.</p>
    </div>
    <div class="p-4 border-t flex justify-end gap-2">
      <button class="btn btn-ghost" id="cancelDeleteBtn">Cancel</button>
      <button class="btn btn-destructive" id="confirmDeleteBtn">Delete</button>
    </div>
  </div>
  
  <!-- JavaScript -->
  <script>
    // Theme handling
    const getThemePreference = () => {
      const storedTheme = localStorage.getItem('theme');
      if (storedTheme) return storedTheme;
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    
    const setTheme = (theme) => {
      if (theme === 'dark') {
        document.documentElement.classList.add('dark');
        document.getElementById('themeToggle').innerHTML = '<i class="ph ph-moon"></i>';
      } else {
        document.documentElement.classList.remove('dark');
        document.getElementById('themeToggle').innerHTML = '<i class="ph ph-sun"></i>';
      }
      localStorage.setItem('theme', theme);
    };
    
    // Initial theme setup
    setTheme(getThemePreference());
    
    // Toggle theme
    document.getElementById('themeToggle').addEventListener('click', () => {
      const currentTheme = localStorage.getItem('theme') || 'light';
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';
      setTheme(newTheme);
    });
    
    // State management
    const state = {
      anime: [],
      episodes: [],
      scheduled: [],
      filteredAnime: [],
      filteredEpisodes: [],
      filteredScheduled: [],
      currentPage: 1,
      itemsPerPage: 20,
      selectedAnime: null,
      deleteTarget: null,
      deleteType: null,
      animeView: 'grid'
    };
    
    // API functions
    const api = {
      baseUrl: '/api',
      
      async fetchAnime() {
        try {
          const response = await fetch(`${this.baseUrl}/anime`);
          if (!response.ok) throw new Error('Failed to fetch anime list');
          const data = await response.json();
          state.anime = data;
          state.filteredAnime = [...data];
          return data;
        } catch (error) {
          console.error('Error fetching anime:', error);
          showToast('Failed to fetch anime list', 'error');
          return [];
        }
      },
      
      async fetchEpisodes() {
        try {
          const response = await fetch(`${this.baseUrl}/episodes`);
          if (!response.ok) throw new Error('Failed to fetch episodes');
          const data = await response.json();
          state.episodes = data;
          state.filteredEpisodes = [...data];
          return data;
        } catch (error) {
          console.error('Error fetching episodes:', error);
          showToast('Failed to fetch episodes', 'error');
          return [];
        }
      },
      
      async fetchScheduled() {
        try {
          const response = await fetch(`${this.baseUrl}/scheduled`);
          if (!response.ok) throw new Error('Failed to fetch scheduled releases');
          const data = await response.json();
          state.scheduled = data;
          state.filteredScheduled = [...data];
          return data;
        } catch (error) {
          console.error('Error fetching scheduled releases:', error);
          showToast('Failed to fetch scheduled releases', 'error');
          return [];
        }
      },
      
      async searchAnime(query) {
        try {
          const response = await fetch(`${this.baseUrl}/search?query=${encodeURIComponent(query)}`);
          if (!response.ok) throw new Error('Failed to search anime');
          return await response.json();
        } catch (error) {
          console.error('Error searching anime:', error);
          showToast('Failed to search anime', 'error');
          return [];
        }
      },
      
      async addAnime(anilistId, hasTagalogDub) {
        try {
          const response = await fetch(`${this.baseUrl}/anime`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ anilistId, hasTagalogDub }),
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to add anime');
          }
          
          const data = await response.json();
          return data;
        } catch (error) {
          console.error('Error adding anime:', error);
          showToast(error.message, 'error');
          throw error;
        }
      },
      
      async addEpisode(episodeData) {
        try {
          const response = await fetch(`${this.baseUrl}/episodes`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(episodeData),
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to add episode');
          }
          
          const data = await response.json();
          return data;
        } catch (error) {
          console.error('Error adding episode:', error);
          showToast(error.message, 'error');
          throw error;
        }
      },
      
      async scheduleRelease(scheduleData) {
        try {
          const response = await fetch(`${this.baseUrl}/scheduled`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(scheduleData),
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to schedule release');
          }
          
          const data = await response.json();
          return data;
        } catch (error) {
          console.error('Error scheduling release:', error);
          showToast(error.message, 'error');
          throw error;
        }
      },
      
      async deleteAnime(animeId) {
        try {
          const response = await fetch(`${this.baseUrl}/anime/${animeId}`, {
            method: 'DELETE'
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to delete anime');
          }
          
          return await response.json();
        } catch (error) {
          console.error('Error deleting anime:', error);
          showToast(error.message, 'error');
          throw error;
        }
      },
      
      async deleteEpisode(episodeId) {
        try {
          const response = await fetch(`${this.baseUrl}/episodes/${episodeId}`, {
            method: 'DELETE'
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to delete episode');
          }
          
          return await response.json();
        } catch (error) {
          console.error('Error deleting episode:', error);
          showToast(error.message, 'error');
          throw error;
        }
      },
      
      async deleteScheduled(scheduleId) {
        try {
          const response = await fetch(`${this.baseUrl}/scheduled/${scheduleId}`, {
            method: 'DELETE'
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to delete scheduled release');
          }
          
          return await response.json();
        } catch (error) {
          console.error('Error deleting scheduled release:', error);
          showToast(error.message, 'error');
          throw error;
        }
      },
      
      async exportData() {
        try {
          const response = await fetch(`${this.baseUrl}/export`);
          if (!response.ok) throw new Error('Failed to export data');
          return await response.json();
        } catch (error) {
          console.error('Error exporting data:', error);
          showToast('Failed to export data', 'error');
          throw error;
        }
      },
      
      async importData(data) {
        try {
          const response = await fetch(`${this.baseUrl}/import`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(data),
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to import data');
          }
          
          return await response.json();
        } catch (error) {
          console.error('Error importing data:', error);
          showToast(error.message, 'error');
          throw error;
        }
      }
    };
    
    // Utility functions
    function showToast(message, type = 'success') {
      const toastContainer = document.getElementById('toastContainer');
      const toast = document.createElement('div');
      toast.classList.add('toast', `toast-${type}`);
      toast.textContent = message;
      
      toastContainer.appendChild(toast);
      
      // Remove after 3 seconds
      setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease-in forwards';
        setTimeout(() => {
          toastContainer.removeChild(toast);
        }, 300);
      }, 3000);
    }
    
    function formatDate(dateString) {
      if (!dateString) return 'Unknown';
      const date = new Date(dateString);
      return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
    }
    
    // Navigation
    function showPage(pageId) {
      // Hide all pages
      document.querySelectorAll('.page-content').forEach(page => {
        page.classList.add('hidden');
      });
      
      // Show the selected page
      document.getElementById(`${pageId}Page`).classList.remove('hidden');
      
      // Update active nav items
      document.querySelectorAll('.sidebar-nav-item, .mobile-nav-item').forEach(item => {
        item.classList.remove('active');
      });
      
      document.querySelectorAll(`.sidebar-nav-item[data-page="${pageId}"], .mobile-nav-item[data-page="${pageId}"]`).forEach(item => {
        item.classList.add('active');
      });
      
      // Load page specific data
      if (pageId === 'dashboard') {
        loadDashboardData();
      } else if (pageId === 'anime') {
        loadAnimeData();
      } else if (pageId === 'episodes') {
        loadEpisodesData();
      } else if (pageId === 'scheduled') {
        loadScheduledData();
      }
      
      // Close mobile menu if open
      document.getElementById('mobileMenu').classList.remove('open');
      document.getElementById('drawerOverlay').classList.remove('open');
    }
    
    // Settings tab navigation
    function showSettingsTab(tabId) {
      // Hide all tab contents
      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
        tab.classList.add('hidden');
      });
      
      // Show the selected tab
      document.getElementById(`${tabId}Tab`).classList.remove('hidden');
      document.getElementById(`${tabId}Tab`).classList.add('active');
      
      // Update active tab buttons
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      
      document.querySelector(`.tab[data-tab="${tabId}"]`).classList.add('active');
    }
    
    // Mobile menu handlers
    document.getElementById('openDrawer').addEventListener('click', () => {
      document.getElementById('mobileMenu').classList.add('open');
      document.getElementById('drawerOverlay').classList.add('open');
    });
    
    document.getElementById('closeDrawer').addEventListener('click', () => {
      document.getElementById('mobileMenu').classList.remove('open');
      document.getElementById('drawerOverlay').classList.remove('open');
    });
    
    document.getElementById('drawerOverlay').addEventListener('click', () => {
      document.getElementById('mobileMenu').classList.remove('open');
      document.getElementById('drawerOverlay').classList.remove('open');
    });
    
    // Navigation event listeners
    document.querySelectorAll('.sidebar-nav-item, .mobile-nav-item').forEach(item => {
      item.addEventListener('click', () => {
        showPage(item.dataset.page);
      });
    });
    
    // Settings tab event listeners
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        showSettingsTab(tab.dataset.tab);
      });
    });
    
    // User dropdown
    document.getElementById('userDropdownBtn').addEventListener('click', () => {
      document.getElementById('userDropdown').classList.toggle('open');
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', (event) => {
      const dropdown = document.getElementById('userDropdown');
      const dropdownBtn = document.getElementById('userDropdownBtn');
      
      if (!dropdownBtn.contains(event.target) && !dropdown.contains(event.target)) {
        dropdown.classList.remove('open');
      }
    });
    
    // Add Anime Dialog
    const addAnimeDialog = {
      dialog: document.getElementById('addAnimeDialog'),
      overlay: document.getElementById('addAnimeOverlay'),
      searchInput: document.getElementById('animeSearchInput'),
      searchBtn: document.getElementById('animeSearchBtn'),
      resultsContainer: document.getElementById('animeSearchResults'),
      resultsList: document.getElementById('animeResultsList'),
      selectedInfoContainer: document.getElementById('selectedAnimeInfo'),
      selectedImage: document.getElementById('selectedAnimeImage'),
      selectedTitle: document.getElementById('selectedAnimeTitle'),
      selectedDetails: document.getElementById('selectedAnimeDetails'),
      selectedDescription: document.getElementById('selectedAnimeDescription'),
      hasTagalogDubCheckbox: document.getElementById('hasTagalogDubCheckbox'),
      cancelBtn: document.getElementById('cancelAddAnimeBtn'),
      confirmBtn: document.getElementById('confirmAddAnimeBtn'),
      
      open() {
        this.dialog.classList.add('open');
        this.overlay.classList.add('open');
        this.reset();
      },
      
      close() {
        this.dialog.classList.remove('open');
        this.overlay.classList.remove('open');
      },
      
      reset() {
        this.searchInput.value = '';
        this.resultsContainer.classList.add('hidden');
        this.selectedInfoContainer.classList.add('hidden');
        this.resultsList.innerHTML = '';
        this.hasTagalogDubCheckbox.checked = false;
        this.confirmBtn.disabled = true;
        state.selectedAnime = null;
      },
      
      async search() {
        const query = this.searchInput.value.trim();
        if (!query) return;
        
        this.resultsList.innerHTML = '<p class="text-center p-4">Searching...</p>';
        this.resultsContainer.classList.remove('hidden');
        
        try {
          const results = await api.searchAnime(query);
          
          if (results.length === 0) {
            this.resultsList.innerHTML = '<p class="text-center p-4">No results found</p>';
            return;
          }
          
          this.resultsList.innerHTML = '';
          
          results.forEach(anime => {
            const resultItem = document.createElement('div');
            resultItem.classList.add('p-3', 'border-b', 'cursor-pointer', 'hover:bg-gray-50', 'dark:hover:bg-gray-800', 'flex', 'items-center', 'gap-3');
            resultItem.innerHTML = `
              <div class="w-12 h-16 bg-gray-200 dark:bg-gray-700 flex-shrink-0">
                ${anime.thumbnail ? `<img src="${anime.thumbnail}" alt="${anime.title}" class="w-full h-full object-cover">` : ''}
              </div>
              <div class="flex-1">
                <h4 class="font-medium line-clamp-1">${anime.title}</h4>
                <p class="text-xs text-gray-500 line-clamp-1">${anime.episodeCount} episodes | ${anime.status}</p>
              </div>
            `;
            
            resultItem.addEventListener('click', () => {
              this.selectAnime(anime);
            });
            
            this.resultsList.appendChild(resultItem);
          });
        } catch (error) {
          this.resultsList.innerHTML = `<p class="text-center p-4 text-red-500">Error: ${error.message}</p>`;
        }
      },
      
      selectAnime(anime) {
        state.selectedAnime = anime;
        this.selectedTitle.textContent = anime.title;
        this.selectedDetails.textContent = `Episodes: ${anime.episodeCount} | Rating: ${anime.rating || 'N/A'} | Status: ${anime.status}`;
        this.selectedDescription.textContent = anime.description || 'No description available';
        
        if (anime.thumbnail) {
          this.selectedImage.innerHTML = `<img src="${anime.thumbnail}" alt="${anime.title}" class="w-full h-full object-cover">`;
          this.selectedImage.classList.remove('skeleton');
        } else {
          this.selectedImage.innerHTML = '';
          this.selectedImage.classList.add('skeleton');
        }
        
        this.selectedInfoContainer.classList.remove('hidden');
        this.confirmBtn.disabled = false;
      },
      
      async addAnime() {
        if (!state.selectedAnime) return;
        
        this.confirmBtn.disabled = true;
        this.confirmBtn.innerHTML = '<div class="spinner mr-2"></div> Adding...';
        
        try {
          const newAnime = await api.addAnime(
            state.selectedAnime.id,
            this.hasTagalogDubCheckbox.checked
          );
          
          state.anime.push(newAnime);
          state.filteredAnime.push(newAnime);
          
          showToast(`Successfully added "${newAnime.title}" to your library`);
          this.close();
          
          // Refresh anime list if on anime page
          if (!document.getElementById('animePage').classList.contains('hidden')) {
            loadAnimeData();
          }
        } catch (error) {
          this.confirmBtn.disabled = false;
          this.confirmBtn.textContent = 'Add to Library';
        }
      }
    };
    
    // Add Anime Dialog Event Listeners
    addAnimeDialog.searchBtn.addEventListener('click', () => addAnimeDialog.search());
    addAnimeDialog.searchInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') addAnimeDialog.search();
    });
    addAnimeDialog.cancelBtn.addEventListener('click', () => addAnimeDialog.close());
    addAnimeDialog.confirmBtn.addEventListener('click', () => addAnimeDialog.addAnime());
    addAnimeDialog.overlay.addEventListener('click', () => addAnimeDialog.close());
    
    // Add Episode Dialog
    const addEpisodeDialog = {
      dialog: document.getElementById('addEpisodeDialog'),
      overlay: document.getElementById('addEpisodeOverlay'),
      animeSelect: document.getElementById('episodeAnimeSelect'),
      episodeNumber: document.getElementById('episodeNumber'),
      episodeTitle: document.getElementById('episodeTitle'),
      iframeSrc: document.getElementById('episodeiFrameSrc'),
      server2Url: document.getElementById('episodeServer2Url'),
      hasTagalogDub: document.getElementById('episodeHasTagalogDub'),
      cancelBtn: document.getElementById('cancelAddEpisodeBtn'),
      confirmBtn: document.getElementById('confirmAddEpisodeBtn'),
      
      open() {
        this.dialog.classList.add('open');
        this.overlay.classList.add('open');
        this.reset();
        this.populateAnimeOptions();
      },
      
      close() {
        this.dialog.classList.remove('open');
        this.overlay.classList.remove('open');
      },
      
      reset() {
        this.animeSelect.value = '';
        this.episodeNumber.value = '';
        this.episodeTitle.value = '';
        this.iframeSrc.value = '';
        this.server2Url.value = '';
        this.hasTagalogDub.checked = false;
      },
      
      populateAnimeOptions() {
        // Clear existing options except the placeholder
        while (this.animeSelect.options.length > 1) {
          this.animeSelect.remove(1);
        }
        
        // Add options based on available anime
        state.anime.forEach(anime => {
          const option = document.createElement('option');
          option.value = anime.id;
          option.textContent = anime.title;
          this.animeSelect.appendChild(option);
        });
      },
      
      validate() {
        if (!this.animeSelect.value) {
          showToast('Please select an anime', 'error');
          return false;
        }
        
        if (!this.episodeNumber.value) {
          showToast('Please enter episode number', 'error');
          return false;
        }
        
        if (!this.iframeSrc.value) {
          showToast('Please enter server 1 URL', 'error');
          return false;
        }
        
        return true;
      },
      
      async addEpisode() {
        if (!this.validate()) return;
        
        this.confirmBtn.disabled = true;
        this.confirmBtn.innerHTML = '<div class="spinner mr-2"></div> Adding...';
        
        const episodeData = {
          animeId: this.animeSelect.value,
          number: parseInt(this.episodeNumber.value),
          title: this.episodeTitle.value || `Episode ${this.episodeNumber.value}`,
          iframeSrc: this.iframeSrc.value,
          server2Url: this.server2Url.value,
          hasTagalogDub: this.hasTagalogDub.checked
        };
        
        try {
          const newEpisode = await api.addEpisode(episodeData);
          
          state.episodes.push(newEpisode);
          state.filteredEpisodes.push(newEpisode);
          
          showToast(`Successfully added episode ${newEpisode.number}`);
          this.close();
          
          // Refresh episodes list if on episodes page
          if (!document.getElementById('episodesPage').classList.contains('hidden')) {
            loadEpisodesData();
          }
        } catch (error) {
          // Error message is shown by API function
        } finally {
          this.confirmBtn.disabled = false;
          this.confirmBtn.textContent = 'Add Episode';
        }
      }
    };
    
    // Add Episode Dialog Event Listeners
    addEpisodeDialog.cancelBtn.addEventListener('click', () => addEpisodeDialog.close());
    addEpisodeDialog.confirmBtn.addEventListener('click', () => addEpisodeDialog.addEpisode());
    addEpisodeDialog.overlay.addEventListener('click', () => addEpisodeDialog.close());
    
    // Schedule Release Dialog
    const scheduleReleaseDialog = {
      dialog: document.getElementById('scheduleReleaseDialog'),
      overlay: document.getElementById('scheduleReleaseOverlay'),
      animeSelect: document.getElementById('scheduleAnimeSelect'),
      releaseDate: document.getElementById('scheduleReleaseDate'),
      notes: document.getElementById('scheduleNotes'),
      hasTagalogDub: document.getElementById('scheduleHasTagalogDub'),
      cancelBtn: document.getElementById('cancelScheduleBtn'),
      confirmBtn: document.getElementById('confirmScheduleBtn'),
      
      open() {
        this.dialog.classList.add('open');
        this.overlay.classList.add('open');
        this.reset();
        this.populateAnimeOptions();
      },
      
      close() {
        this.dialog.classList.remove('open');
        this.overlay.classList.remove('open');
      },
      
      reset() {
        this.animeSelect.value = '';
        this.releaseDate.value = '';
        this.notes.value = '';
        this.hasTagalogDub.checked = false;
      },
      
      populateAnimeOptions() {
        // Clear existing options except the placeholder
        while (this.animeSelect.options.length > 1) {
          this.animeSelect.remove(1);
        }
        
        // Add options based on available anime
        state.anime.forEach(anime => {
          const option = document.createElement('option');
          option.value = anime.id;
          option.textContent = anime.title;
          this.animeSelect.appendChild(option);
        });
      },
      
      validate() {
        if (!this.animeSelect.value) {
          showToast('Please select an anime', 'error');
          return false;
        }
        
        if (!this.releaseDate.value) {
          showToast('Please select a release date', 'error');
          return false;
        }
        
        return true;
      },
      
      async scheduleRelease() {
        if (!this.validate()) return;
        
        this.confirmBtn.disabled = true;
        this.confirmBtn.innerHTML = '<div class="spinner mr-2"></div> Scheduling...';
        
        const scheduleData = {
          anilistId: this.animeSelect.value,
          releaseDate: this.releaseDate.value,
          notes: this.notes.value,
          hasTagalogDub: this.hasTagalogDub.checked
        };
        
        try {
          const newSchedule = await api.scheduleRelease(scheduleData);
          
          state.scheduled.push(newSchedule);
          state.filteredScheduled.push(newSchedule);
          
          showToast(`Successfully scheduled ${newSchedule.title}`);
          this.close();
          
          // Refresh scheduled list if on scheduled page
          if (!document.getElementById('scheduledPage').classList.contains('hidden')) {
            loadScheduledData();
          }
        } catch (error) {
          // Error message is shown by API function
        } finally {
          this.confirmBtn.disabled = false;
          this.confirmBtn.textContent = 'Schedule Release';
        }
      }
    };
    
    // Schedule Release Dialog Event Listeners
    scheduleReleaseDialog.cancelBtn.addEventListener('click', () => scheduleReleaseDialog.close());
    scheduleReleaseDialog.confirmBtn.addEventListener('click', () => scheduleReleaseDialog.scheduleRelease());
    scheduleReleaseDialog.overlay.addEventListener('click', () => scheduleReleaseDialog.close());
    
    // Delete Confirmation Dialog
    const deleteConfirmDialog = {
      dialog: document.getElementById('deleteConfirmDialog'),
      overlay: document.getElementById('deleteConfirmOverlay'),
      message: document.getElementById('deleteConfirmMessage'),
      cancelBtn: document.getElementById('cancelDeleteBtn'),
      confirmBtn: document.getElementById('confirmDeleteBtn'),
      
      open(type, id, name) {
        this.dialog.classList.add('open');
        this.overlay.classList.add('open');
        
        state.deleteType = type;
        state.deleteTarget = id;
        
        let typeDisplay = 'item';
        if (type === 'anime') typeDisplay = 'anime';
        else if (type === 'episode') typeDisplay = 'episode';
        else if (type === 'scheduled') typeDisplay = 'scheduled release';
        
        this.message.textContent = `Are you sure you want to delete this ${typeDisplay}${name ? ` "${name}"` : ''}? This action cannot be undone.`;
      },
      
      close() {
        this.dialog.classList.remove('open');
        this.overlay.classList.remove('open');
        state.deleteType = null;
        state.deleteTarget = null;
      },
      
      async confirmDelete() {
        if (!state.deleteType || !state.deleteTarget) return;
        
        this.confirmBtn.disabled = true;
        this.confirmBtn.innerHTML = '<div class="spinner mr-2"></div> Deleting...';
        
        try {
          let result;
          
          if (state.deleteType === 'anime') {
            result = await api.deleteAnime(state.deleteTarget);
            
            // Remove from state
            state.anime = state.anime.filter(a => a.id !== state.deleteTarget);
            state.filteredAnime = state.filteredAnime.filter(a => a.id !== state.deleteTarget);
            
            // Also remove associated episodes
            state.episodes = state.episodes.filter(e => e.animeId !== state.deleteTarget);
            state.filteredEpisodes = state.filteredEpisodes.filter(e => e.animeId !== state.deleteTarget);
            
            // Remove associated scheduled entries
            state.scheduled = state.scheduled.filter(s => s.animeId !== state.deleteTarget);
            state.filteredScheduled = state.filteredScheduled.filter(s => s.animeId !== state.deleteTarget);
            
            showToast('Anime and associated data deleted successfully');
          } else if (state.deleteType === 'episode') {
            result = await api.deleteEpisode(state.deleteTarget);
            
            // Remove from state
            state.episodes = state.episodes.filter(e => e.id !== state.deleteTarget);
            state.filteredEpisodes = state.filteredEpisodes.filter(e => e.id !== state.deleteTarget);
            
            showToast('Episode deleted successfully');
          } else if (state.deleteType === 'scheduled') {
            result = await api.deleteScheduled(state.deleteTarget);
            
            // Remove from state
            state.scheduled = state.scheduled.filter(s => s.id !== state.deleteTarget);
            state.filteredScheduled = state.filteredScheduled.filter(s => s.id !== state.deleteTarget);
            
            showToast('Scheduled release deleted successfully');
          }
          
          this.close();
          
          // Refresh the current page
          const currentPage = document.querySelector('.page-content:not(.hidden)').id;
          if (currentPage === 'animePage') {
            renderAnimeList();
          } else if (currentPage === 'episodesPage') {
            renderEpisodesList();
          } else if (currentPage === 'scheduledPage') {
            renderScheduledList();
          } else if (currentPage === 'dashboardPage') {
            loadDashboardData();
          }
        } catch (error) {
          // Error message is shown by API function
        } finally {
          this.confirmBtn.disabled = false;
          this.confirmBtn.textContent = 'Delete';
        }
      }
    };
    
    // Delete Confirmation Dialog Event Listeners
    deleteConfirmDialog.cancelBtn.addEventListener('click', () => deleteConfirmDialog.close());
    deleteConfirmDialog.confirmBtn.addEventListener('click', () => deleteConfirmDialog.confirmDelete());
    deleteConfirmDialog.overlay.addEventListener('click', () => deleteConfirmDialog.close());
    
    // Load and render dashboard
    async function loadDashboardData() {
      // Fetch all necessary data
      try {
        await Promise.all([
          api.fetchAnime(),
          api.fetchEpisodes(),
          api.fetchScheduled()
        ]);
        
        // Update dashboard stats
        renderDashboardStats();
        renderRecentActivity();
        renderUpcomingReleases();
      } catch (error) {
        console.error('Error loading dashboard data:', error);
      }
    }
    
    function renderDashboardStats() {
      const totalAnimeCount = document.getElementById('totalAnimeCount');
      const totalEpisodesCount = document.getElementById('totalEpisodesCount');
      const scheduledCount = document.getElementById('scheduledCount');
      const tagalogDubbedCount = document.getElementById('tagalogDubbedCount');
      const animeGrowth = document.getElementById('animeGrowth');
      const episodesGrowth = document.getElementById('episodesGrowth');
      const nextScheduled = document.getElementById('nextScheduled');
      const tagalogPercentage = document.getElementById('tagalogPercentage');
      
      // Set counts
      totalAnimeCount.textContent = state.anime.length;
      totalEpisodesCount.textContent = state.episodes.length;
      scheduledCount.textContent = state.scheduled.length;
      
      // Calculate tagalog dub count
      const tagalogDubbed = state.anime.filter(a => a.hasTagalogDub).length;
      tagalogDubbedCount.textContent = tagalogDubbed;
      
      // Calculate percentage
      const tagalogPercent = state.anime.length > 0 
        ? Math.round((tagalogDubbed / state.anime.length) * 100) 
        : 0;
      tagalogPercentage.textContent = `${tagalogPercent}% of library`;
      
      // Calculate recent growth (last 30 days)
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      
      const recentAnime = state.anime.filter(a => new Date(a.dateAdded) > thirtyDaysAgo).length;
      const recentEpisodes = state.episodes.filter(e => new Date(e.dateAdded) > thirtyDaysAgo).length;
      
      animeGrowth.textContent = `${recentAnime} added in last 30 days`;
      episodesGrowth.textContent = `${recentEpisodes} added in last 30 days`;
      
      // Find next scheduled release
      const now = new Date();
      const upcomingReleases = state.scheduled
        .filter(s => new Date(s.releaseDate) > now)
        .sort((a, b) => new Date(a.releaseDate) - new Date(b.releaseDate));
      
      if (upcomingReleases.length > 0) {
        const next = upcomingReleases[0];
        nextScheduled.textContent = `Next: ${formatDate(next.releaseDate)}`;
      } else {
        nextScheduled.textContent = 'No upcoming releases';
      }
    }
    
    function renderRecentActivity() {
      const recentActivityContainer = document.getElementById('recentActivityContainer');
      recentActivityContainer.innerHTML = '';
      
      // Combine recent anime, episodes, and scheduled
      const recentItems = [
        ...state.anime.map(a => ({ type: 'anime', item: a, date: a.dateAdded })),
        ...state.episodes.map(e => ({ type: 'episode', item: e, date: e.dateAdded })),
        ...state.scheduled.map(s => ({ type: 'scheduled', item: s, date: s.dateAdded }))
      ];
      
      // Sort by date (most recent first)
      recentItems.sort((a, b) => new Date(b.date) - new Date(a.date));
      
      // Display the 5 most recent items
      const recentActivity = recentItems.slice(0, 5);
      
      if (recentActivity.length === 0) {
        recentActivityContainer.innerHTML = '<p class="text-center text-gray-500 py-4">No recent activity</p>';
        return;
      }
      
      recentActivity.forEach(activity => {
        const activityItem = document.createElement('div');
        activityItem.classList.add('flex', 'items-center', 'gap-3');
        
        let icon, title, details;
        
        if (activity.type === 'anime') {
          icon = '<i class="ph ph-television text-blue-500"></i>';
          title = `Added anime: <span class="font-medium">${activity.item.title}</span>`;
          details = `${formatDate(activity.item.dateAdded)}`;
        } else if (activity.type === 'episode') {
          icon = '<i class="ph ph-film-strip text-green-500"></i>';
          // Find anime title
          const anime = state.anime.find(a => a.id === activity.item.animeId);
          const animeTitle = anime ? anime.title : 'Unknown anime';
          
          title = `Added episode for <span class="font-medium">${animeTitle}</span>`;
          details = `Episode ${activity.item.number} • ${formatDate(activity.item.dateAdded)}`;
        } else if (activity.type === 'scheduled') {
          icon = '<i class="ph ph-calendar text-purple-500"></i>';
          title = `Scheduled: <span class="font-medium">${activity.item.title}</span>`;
          details = `Release date: ${formatDate(activity.item.releaseDate)}`;
        }
        
        activityItem.innerHTML = `
          <div class="w-8 h-8 flex items-center justify-center rounded-full bg-gray-100 dark:bg-gray-800">
            ${icon}
          </div>
          <div class="flex-1">
            <div>${title}</div>
            <div class="text-sm text-gray-500">${details}</div>
          </div>
        `;
        
        recentActivityContainer.appendChild(activityItem);
      });
    }
    
    function renderUpcomingReleases() {
      const upcomingReleasesContainer = document.getElementById('upcomingReleasesContainer');
      upcomingReleasesContainer.innerHTML = '';
      
      // Get upcoming releases (sorted by date)
      const now = new Date();
      const upcomingReleases = state.scheduled
        .filter(s => new Date(s.releaseDate) > now)
        .sort((a, b) => new Date(a.releaseDate) - new Date(b.releaseDate))
        .slice(0, 3); // Show only 3 upcoming releases
      
      if (upcomingReleases.length === 0) {
        upcomingReleasesContainer.innerHTML = '<p class="text-center text-gray-500 py-4">No upcoming releases</p>';
        return;
      }
      
      upcomingReleases.forEach(release => {
        const releaseItem = document.createElement('div');
        releaseItem.classList.add('flex', 'gap-3');
        
        const animeTitle = release.title || 'Unknown anime';
        const releaseDateFormatted = formatDate(release.releaseDate);
        const tagalogBadge = release.hasTagalogDub 
          ? '<span class="badge badge-primary ml-2">Tagalog</span>' 
          : '';
        
        releaseItem.innerHTML = `
          <div class="w-12 h-16 bg-gray-100 dark:bg-gray-800 flex-shrink-0">
            ${release.thumbnail 
              ? `<img src="${release.thumbnail}" alt="${animeTitle}" class="w-full h-full object-cover">` 
              : '<div class="w-full h-full flex items-center justify-center"><i class="ph ph-image text-gray-400"></i></div>'}
          </div>
          <div class="flex-1">
            <div class="font-medium">${animeTitle} ${tagalogBadge}</div>
            <div class="text-sm text-gray-500">Release date: ${releaseDateFormatted}</div>
            ${release.notes ? `<div class="text-sm mt-1">${release.notes}</div>` : ''}
          </div>
        `;
        
        upcomingReleasesContainer.appendChild(releaseItem);
      });
    }
    
    // Anime page functions
    async function loadAnimeData() {
      try {
        await api.fetchAnime();
        renderAnimeList();
      } catch (error) {
        console.error('Error loading anime data:', error);
      }
    }
    
    function renderAnimeList() {
      const animeGridContainer = document.getElementById('animeGridContainer');
      const animeListBody = document.getElementById('animeListBody');
      const paginationInfo = document.getElementById('animePaginationInfo');
      
      // Pagination setup
      const totalItems = state.filteredAnime.length;
      const totalPages = Math.ceil(totalItems / state.itemsPerPage);
      const startIndex = (state.currentPage - 1) * state.itemsPerPage;
      const endIndex = Math.min(startIndex + state.itemsPerPage, totalItems);
      
      // Update pagination controls
      document.getElementById('prevPageBtn').disabled = state.currentPage === 1;
      document.getElementById('nextPageBtn').disabled = state.currentPage >= totalPages;
      paginationInfo.textContent = `Showing ${startIndex + 1}-${endIndex} of ${totalItems} entries`;
      
      // Get items for current page
      const currentItems = state.filteredAnime.slice(startIndex, endIndex);
      
      // Clear containers
      animeGridContainer.innerHTML = '';
      animeListBody.innerHTML = '';
      
      // No items case
      if (currentItems.length === 0) {
        if (state.filteredAnime.length === 0) {
          animeGridContainer.innerHTML = '<div class="col-span-full text-center py-10 text-gray-500">No anime found in your library</div>';
          animeListBody.innerHTML = '<tr><td colspan="6" class="text-center py-8 text-gray-500">No anime found in your library</td></tr>';
        } else {
          animeGridContainer.innerHTML = '<div class="col-span-full text-center py-10 text-gray-500">No anime match your search criteria</div>';
          animeListBody.innerHTML = '<tr><td colspan="6" class="text-center py-8 text-gray-500">No anime match your search criteria</td></tr>';
        }
        return;
      }
      
      // Render grid view items
      currentItems.forEach(anime => {
        const animeCard = document.createElement('div');
        animeCard.classList.add('card', 'overflow-hidden', 'flex', 'flex-col');
        
        const tagalogBadge = anime.hasTagalogDub 
          ? '<span class="badge badge-primary absolute top-2 right-2">Tagalog</span>' 
          : '';
        
        animeCard.innerHTML = `
          <div class="relative h-48 bg-gray-200 dark:bg-gray-700">
            ${anime.thumbnail 
              ? `<img src="${anime.thumbnail}" alt="${anime.title}" class="w-full h-full object-cover">` 
              : '<div class="w-full h-full flex items-center justify-center"><i class="ph ph-image text-gray-400 text-4xl"></i></div>'}
            ${tagalogBadge}
          </div>
          <div class="p-4 flex-1 flex flex-col">
            <h3 class="font-medium line-clamp-2 mb-1">${anime.title}</h3>
            <div class="text-sm text-gray-500 mb-auto">
              <div>Episodes: ${anime.episodeCount}</div>
              <div>Rating: ${anime.rating ? anime.rating.toFixed(1) : 'N/A'}</div>
            </div>
            <div class="flex gap-2 mt-4">
              <button class="btn btn-sm btn-secondary flex-1 view-anime-btn" data-id="${anime.id}">
                <i class="ph ph-eye mr-1"></i> View
              </button>
              <button class="btn btn-sm btn-ghost btn-icon delete-anime-btn" data-id="${anime.id}" data-title="${anime.title}">
                <i class="ph ph-trash text-red-500"></i>
              </button>
            </div>
          </div>
        `;
        
        animeGridContainer.appendChild(animeCard);
      });
      
      // Render list view items
      currentItems.forEach(anime => {
        const tr = document.createElement('tr');
        
        // Count episodes for this anime
        const episodeCount = state.episodes.filter(e => e.animeId === anime.id).length;
        
        tr.innerHTML = `
          <td class="flex items-center gap-2">
            <div class="w-10 h-14 bg-gray-100 dark:bg-gray-800 flex-shrink-0">
              ${anime.thumbnail 
                ? `<img src="${anime.thumbnail}" alt="${anime.title}" class="w-full h-full object-cover">` 
                : '<div class="w-full h-full flex items-center justify-center"><i class="ph ph-image text-gray-400"></i></div>'}
            </div>
            <span class="font-medium">${anime.title}</span>
          </td>
          <td>${episodeCount} / ${anime.episodeCount}</td>
          <td>${anime.rating ? anime.rating.toFixed(1) : 'N/A'}/10</td>
          <td>${anime.status}</td>
          <td>
            ${anime.hasTagalogDub 
              ? '<span class="text-green-500"><i class="ph ph-check-circle"></i> Yes</span>' 
              : '<span class="text-gray-400"><i class="ph ph-x-circle"></i> No</span>'}
          </td>
          <td>
            <div class="flex gap-1">
              <button class="btn btn-ghost btn-icon btn-sm view-anime-btn" data-id="${anime.id}">
                <i class="ph ph-eye"></i>
              </button>
              <button class="btn btn-ghost btn-icon btn-sm add-episode-btn" data-id="${anime.id}">
                <i class="ph ph-plus"></i>
              </button>
              <button class="btn btn-ghost btn-icon btn-sm delete-anime-btn" data-id="${anime.id}" data-title="${anime.title}">
                <i class="ph ph-trash text-red-500"></i>
              </button>
            </div>
          </td>
        `;
        
        animeListBody.appendChild(tr);
      });
      
      // Add event listeners to buttons
      document.querySelectorAll('.view-anime-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const animeId = btn.dataset.id;
          // TODO: Implement view anime details
          console.log('View anime', animeId);
        });
      });
      
      document.querySelectorAll('.add-episode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const animeId = btn.dataset.id;
          document.getElementById('episodeAnimeSelect').value = animeId;
          addEpisodeDialog.open();
        });
      });
      
      document.querySelectorAll('.delete-anime-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const animeId = btn.dataset.id;
          const animeTitle = btn.dataset.title;
          deleteConfirmDialog.open('anime', animeId, animeTitle);
        });
      });
    }
    
    // Filter and toggle view for anime list
    document.getElementById('animeSearch').addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase();
      
      if (searchTerm.trim() === '') {
        state.filteredAnime = [...state.anime];
      } else {
        state.filteredAnime = state.anime.filter(anime => 
          anime.title.toLowerCase().includes(searchTerm)
        );
      }
      
      state.currentPage = 1;
      renderAnimeList();
    });
    
    document.getElementById('animeFilter').addEventListener('change', (e) => {
      const filter = e.target.value;
      
      if (filter === 'all') {
        state.filteredAnime = [...state.anime];
      } else if (filter === 'tagalog') {
        state.filteredAnime = state.anime.filter(anime => anime.hasTagalogDub);
      } else if (filter === 'recent') {
        // Sort by date added (most recent first)
        state.filteredAnime = [...state.anime].sort((a, b) => 
          new Date(b.dateAdded) - new Date(a.dateAdded)
        );
      }
      
      state.currentPage = 1;
      renderAnimeList();
    });
    
    document.getElementById('animeSort').addEventListener('change', (e) => {
      const sort = e.target.value;
      
      if (sort === 'title') {
        state.filteredAnime.sort((a, b) => a.title.localeCompare(b.title));
      } else if (sort === 'dateAdded') {
        state.filteredAnime.sort((a, b) => new Date(b.dateAdded) - new Date(a.dateAdded));
      } else if (sort === 'popularity') {
        state.filteredAnime.sort((a, b) => (b.popularity || 0) - (a.popularity || 0));
      } else if (sort === 'rating') {
        state.filteredAnime.sort((a, b) => (b.rating || 0) - (a.rating || 0));
      }
      
      renderAnimeList();
    });
    
    document.getElementById('gridViewBtn').addEventListener('click', () => {
      document.getElementById('animeGridContainer').classList.remove('hidden');
      document.getElementById('animeListContainer').classList.add('hidden');
      document.getElementById('gridViewBtn').classList.add('bg-blue-50', 'dark:bg-gray-800');
      document.getElementById('listViewBtn').classList.remove('bg-blue-50', 'dark:bg-gray-800');
      state.animeView = 'grid';
    });
    
    document.getElementById('listViewBtn').addEventListener('click', () => {
      document.getElementById('animeGridContainer').classList.add('hidden');
      document.getElementById('animeListContainer').classList.remove('hidden');
      document.getElementById('gridViewBtn').classList.remove('bg-blue-50', 'dark:bg-gray-800');
      document.getElementById('listViewBtn').classList.add('bg-blue-50', 'dark:bg-gray-800');
      state.animeView = 'list';
    });
    
    document.getElementById('prevPageBtn').addEventListener('click', () => {
      if (state.currentPage > 1) {
        state.currentPage--;
        renderAnimeList();
      }
    });
    
    document.getElementById('nextPageBtn').addEventListener('click', () => {
      const totalPages = Math.ceil(state.filteredAnime.length / state.itemsPerPage);
      if (state.currentPage < totalPages) {
        state.currentPage++;
        renderAnimeList();
      }
    });
    
    // Episodes page functions
    async function loadEpisodesData() {
      try {
        await Promise.all([
          api.fetchAnime(),
          api.fetchEpisodes()
        ]);
        
        // Populate anime filter
        const animeFilter = document.getElementById('episodeAnimeFilter');
        
        // Clear options except the "All Anime" option
        while (animeFilter.options.length > 1) {
          animeFilter.remove(1);
        }
        
        // Add options based on available anime
        state.anime.forEach(anime => {
          const option = document.createElement('option');
          option.value = anime.id;
          option.textContent = anime.title;
          animeFilter.appendChild(option);
        });
        
        renderEpisodesList();
      } catch (error) {
        console.error('Error loading episodes data:', error);
      }
    }
    
    function renderEpisodesList() {
      const episodesTableBody = document.getElementById('episodesTableBody');
      const paginationInfo = document.getElementById('episodePaginationInfo');
      
      // Pagination setup
      const totalItems = state.filteredEpisodes.length;
      const totalPages = Math.ceil(totalItems / state.itemsPerPage);
      const startIndex = (state.currentPage - 1) * state.itemsPerPage;
      const endIndex = Math.min(startIndex + state.itemsPerPage, totalItems);
      
      // Update pagination controls
      document.getElementById('episodePrevPageBtn').disabled = state.currentPage === 1;
      document.getElementById('episodeNextPageBtn').disabled = state.currentPage >= totalPages;
      paginationInfo.textContent = `Showing ${startIndex + 1}-${endIndex} of ${totalItems} entries`;
      
      // Get items for current page
      const currentEpisodes = state.filteredEpisodes.slice(startIndex, endIndex);
      
      // Clear container
      episodesTableBody.innerHTML = '';
      
      // No items case
      if (currentEpisodes.length === 0) {
        if (state.filteredEpisodes.length === 0) {
          episodesTableBody.innerHTML = '<tr><td colspan="6" class="text-center py-8 text-gray-500">No episodes found</td></tr>';
        } else {
          episodesTableBody.innerHTML = '<tr><td colspan="6" class="text-center py-8 text-gray-500">No episodes match your filter criteria</td></tr>';
        }
        return;
      }
      
      // Render table rows
      currentEpisodes.forEach(episode => {
        const tr = document.createElement('tr');
        
        // Find anime for this episode
        const anime = state.anime.find(a => a.id === episode.animeId);
        const animeTitle = anime ? anime.title : 'Unknown anime';
        
        tr.innerHTML = `
          <td>
            <div class="flex items-center gap-2">
              ${anime && anime.thumbnail ? 
                `<div class="w-8 h-8 rounded">
                  <img src="${anime.thumbnail}" alt="${animeTitle}" class="w-full h-full object-cover rounded">
                </div>` : 
                ''}
              <span>${animeTitle}</span>
            </div>
          </td>
          <td>${episode.number}</td>
          <td>${episode.title}</td>
          <td>
            ${episode.hasTagalogDub ? 
              '<span class="badge badge-primary">Tagalog</span>' : 
              '<span class="badge badge-secondary">Subbed</span>'}
          </td>
          <td>${formatDate(episode.dateAdded)}</td>
          <td>
            <div class="flex gap-1">
              <button class="btn btn-ghost btn-icon btn-sm view-episode-btn" data-id="${episode.id}">
                <i class="ph ph-play"></i>
              </button>
              <button class="btn btn-ghost btn-icon btn-sm edit-episode-btn" data-id="${episode.id}">
                <i class="ph ph-pencil"></i>
              </button>
              <button class="btn btn-ghost btn-icon btn-sm delete-episode-btn" data-id="${episode.id}" data-title="${episode.title}">
                <i class="ph ph-trash text-red-500"></i>
              </button>
            </div>
          </td>
        `;
        
        episodesTableBody.appendChild(tr);
      });
      
      // Add event listeners to buttons
      document.querySelectorAll('.view-episode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const episodeId = btn.dataset.id;
          // TODO: Implement view episode
          console.log('View episode', episodeId);
        });
      });
      
      document.querySelectorAll('.edit-episode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const episodeId = btn.dataset.id;
          // TODO: Implement edit episode
          console.log('Edit episode', episodeId);
        });
      });
      
      document.querySelectorAll('.delete-episode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const episodeId = btn.dataset.id;
          const episodeTitle = btn.dataset.title;
          deleteConfirmDialog.open('episode', episodeId, episodeTitle);
        });
      });
    }
    
    // Episode filters
    document.getElementById('episodeSearch').addEventListener('input', (e) => {
      const searchTerm = e.target.value.toLowerCase();
      
      filterEpisodes();
    });
    
    document.getElementById('episodeAnimeFilter').addEventListener('change', () => {
      filterEpisodes();
    });
    
    document.getElementById('episodeLanguageFilter').addEventListener('change', () => {
      filterEpisodes();
    });
    
    document.getElementById('episodeSortOrder').addEventListener('change', () => {
      filterEpisodes();
    });
    
    function filterEpisodes() {
      const searchTerm = document.getElementById('episodeSearch').value.toLowerCase();
      const animeFilter = document.getElementById('episodeAnimeFilter').value;
      const languageFilter = document.getElementById('episodeLanguageFilter').value;
      const sortOrder = document.getElementById('episodeSortOrder').value;
      
      // Filter episodes
      state.filteredEpisodes = state.episodes.filter(episode => {
        // Search filter
        if (searchTerm.trim() !== '') {
          const anime = state.anime.find(a => a.id === episode.animeId);
          const animeTitle = anime ? anime.title.toLowerCase() : '';
          
          if (!episode.title.toLowerCase().includes(searchTerm) && 
              !animeTitle.includes(searchTerm) &&
              !episode.number.toString().includes(searchTerm)) {
            return false;
          }
        }
        
        // Anime filter
        if (animeFilter !== 'all' && episode.animeId !== animeFilter) {
          return false;
        }
        
        // Language filter
        if (languageFilter === 'tagalog' && !episode.hasTagalogDub) {
          return false;
        } else if (languageFilter === 'subbed' && episode.hasTagalogDub) {
          return false;
        }
        
        return true;
      });
      
      // Sort episodes
      if (sortOrder === 'newest') {
        state.filteredEpisodes.sort((a, b) => new Date(b.dateAdded) - new Date(a.dateAdded));
      } else if (sortOrder === 'oldest') {
        state.filteredEpisodes.sort((a, b) => new Date(a.dateAdded) - new Date(b.dateAdded));
      } else if (sortOrder === 'episode_asc') {
        state.filteredEpisodes.sort((a, b) => {
          if (a.animeId === b.animeId) {
            return a.number - b.number;
          }
          return a.animeId.localeCompare(b.animeId);
        });
      } else if (sortOrder === 'episode_desc') {
        state.filteredEpisodes.sort((a, b) => {
          if (a.animeId === b.animeId) {
            return b.number - a.number;
          }
          return a.animeId.localeCompare(b.animeId);
        });
      }
      
      state.currentPage = 1;
      renderEpisodesList();
    }
    
    document.getElementById('episodePrevPageBtn').addEventListener('click', () => {
      if (state.currentPage > 1) {
        state.currentPage--;
        renderEpisodesList();
      }
    });
    
    document.getElementById('episodeNextPageBtn').addEventListener('click', () => {
      const totalPages = Math.ceil(state.filteredEpisodes.length / state.itemsPerPage);
      if (state.currentPage < totalPages) {
        state.currentPage++;
        renderEpisodesList();
      }
    });
    
    // Scheduled page functions
    async function loadScheduledData() {
      try {
        await Promise.all([
          api.fetchAnime(),
          api.fetchScheduled()
        ]);
        
        renderScheduledList();
        renderCalendar();
      } catch (error) {
        console.error('Error loading scheduled data:', error);
      }
    }
    
    function renderScheduledList() {
      const scheduledTableBody = document.getElementById('scheduledTableBody');
      
      // Clear container
      scheduledTableBody.innerHTML = '';
      
      // No items case
      if (state.scheduled.length === 0) {
        scheduledTableBody.innerHTML = '<tr><td colspan="5" class="text-center py-8 text-gray-500">No scheduled releases found</td></tr>';
        return;
      }
      
      // Sort by release date (ascending)
      const sortedScheduled = [...state.scheduled].sort((a, b) => 
        new Date(a.releaseDate) - new Date(b.releaseDate)
      );
      
      // Render table rows
      sortedScheduled.forEach(item => {
        const tr = document.createElement('tr');
        
        tr.innerHTML = `
          <td>
            <div class="flex items-center gap-2">
              ${item.thumbnail ? 
                `<div class="w-8 h-8 rounded">
                  <img src="${item.thumbnail}" alt="${item.title}" class="w-full h-full object-cover rounded">
                </div>` : 
                ''}
              <span>${item.title}</span>
            </div>
          </td>
          <td>${formatDate(item.releaseDate)}</td>
          <td>
            ${item.hasTagalogDub ? 
              '<span class="badge badge-primary">Tagalog</span>' : 
              '<span class="badge badge-secondary">Subbed</span>'}
          </td>
          <td>${item.notes || '-'}</td>
          <td>
            <div class="flex gap-1">
              <button class="btn btn-ghost btn-icon btn-sm edit-scheduled-btn" data-id="${item.id}">
                <i class="ph ph-pencil"></i>
              </button>
              <button class="btn btn-ghost btn-icon btn-sm delete-scheduled-btn" data-id="${item.id}" data-title="${item.title}">
                <i class="ph ph-trash text-red-500"></i>
              </button>
            </div>
          </td>
        `;
        
        scheduledTableBody.appendChild(tr);
      });
      
      // Add event listeners to buttons
      document.querySelectorAll('.edit-scheduled-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const scheduleId = btn.dataset.id;
          // TODO: Implement edit scheduled
          console.log('Edit scheduled', scheduleId);
        });
      });
      
      document.querySelectorAll('.delete-scheduled-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const scheduleId = btn.dataset.id;
          const scheduleTitle = btn.dataset.title;
          deleteConfirmDialog.open('scheduled', scheduleId, scheduleTitle);
        });
      });
    }
    
    function renderCalendar() {
      const calendarContainer = document.getElementById('calendarContainer');
      const currentMonthYear = document.getElementById('currentMonthYear');
      
      // Get current date values
      const now = new Date();
      const currentYear = now.getFullYear();
      const currentMonth = now.getMonth();
      
      // Calendar state
      let displayMonth = currentMonth;
      let displayYear = currentYear;
      
      // Set current month/year display
      currentMonthYear.textContent = new Date(displayYear, displayMonth, 1)
        .toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
      
      // Function to build calendar for a specific month/year
      function buildCalendar(year, month) {
        // First day of the month
        const firstDay = new Date(year, month, 1).getDay();
        
        // Last day of the month
        const lastDate = new Date(year, month + 1, 0).getDate();
        
        // Get scheduled items for this month
        const monthScheduled = state.scheduled.filter(item => {
          const itemDate = new Date(item.releaseDate);
          return itemDate.getFullYear() === year && itemDate.getMonth() === month;
        });
        
        // Create the calendar HTML
        let calendarHTML = `
          <div class="grid grid-cols-7 gap-1">
            <div class="text-center font-medium p-2">Sun</div>
            <div class="text-center font-medium p-2">Mon</div>
            <div class="text-center font-medium p-2">Tue</div>
            <div class="text-center font-medium p-2">Wed</div>
            <div class="text-center font-medium p-2">Thu</div>
            <div class="text-center font-medium p-2">Fri</div>
            <div class="text-center font-medium p-2">Sat</div>
        `;
        
        // Empty cells for days before the first day of the month
        for (let i = 0; i < firstDay; i++) {
          calendarHTML += `<div class="border rounded-md p-2 min-h-16 bg-gray-50 dark:bg-gray-800"></div>`;
        }
        
        // Days of the month
        for (let date = 1; date <= lastDate; date++) {
          // Check if current date matches today
          const isToday = date === now.getDate() && month === now.getMonth() && year === now.getFullYear();
          
          // Find scheduled items for this date
          const dateScheduled = monthScheduled.filter(item => {
            const itemDate = new Date(item.releaseDate);
            return itemDate.getDate() === date;
          });
          
          // Day cell classes
          let dayClasses = 'border rounded-md p-2 min-h-16 relative';
          if (isToday) {
            dayClasses += ' bg-blue-50 dark:bg-blue-900/20';
          }
          
          calendarHTML += `<div class="${dayClasses}">
            <div class="text-right ${isToday ? 'font-bold text-blue-600 dark:text-blue-400' : ''}">${date}</div>
            <div class="mt-1">
          `;
          
          // Add scheduled items
          if (dateScheduled.length > 0) {
            dateScheduled.forEach((item, idx) => {
              if (idx < 2) {
                calendarHTML += `
                  <div class="text-xs p-1 mb-1 rounded bg-blue-100 dark:bg-blue-900/40 truncate" title="${item.title}">
                    ${item.hasTagalogDub ? '🇵🇭 ' : ''}${item.title}
                  </div>
                `;
              } else if (idx === 2) {
                calendarHTML += `
                  <div class="text-xs p-1 rounded bg-gray-100 dark:bg-gray-700 text-center">
                    +${dateScheduled.length - 2} more
                  </div>
                `;
              }
            });
          }
          
          calendarHTML += `
            </div>
          </div>`;
        }
        
        // Fill in any remaining cells
        const totalCells = 42; // 6 rows x 7 days
        const remainingCells = totalCells - (firstDay + lastDate);
        for (let i = 0; i < remainingCells; i++) {
          calendarHTML += `<div class="border rounded-md p-2 min-h-16 bg-gray-50 dark:bg-gray-800"></div>`;
        }
        
        calendarHTML += `</div>`;
        calendarContainer.innerHTML = calendarHTML;
      }
      
      // Initial build
      buildCalendar(displayYear, displayMonth);
      
      // Month navigation
      document.getElementById('prevMonthBtn').addEventListener('click', () => {
        displayMonth--;
        if (displayMonth < 0) {
          displayMonth = 11;
          displayYear--;
        }
        currentMonthYear.textContent = new Date(displayYear, displayMonth, 1)
          .toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        buildCalendar(displayYear, displayMonth);
      });
      
      document.getElementById('nextMonthBtn').addEventListener('click', () => {
        displayMonth++;
        if (displayMonth > 11) {
          displayMonth = 0;
          displayYear++;
        }
        currentMonthYear.textContent = new Date(displayYear, displayMonth, 1)
          .toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        buildCalendar(displayYear, displayMonth);
      });
    }
    
    // Settings page functions
    document.getElementById('themeSelect').addEventListener('change', (e) => {
      setTheme(e.target.value);
    });
    
    document.getElementById('itemsPerPage').addEventListener('change', (e) => {
      state.itemsPerPage = parseInt(e.target.value);
      state.currentPage = 1;
      
      // Refresh the current list
      const currentPage = document.querySelector('.page-content:not(.hidden)').id;
      if (currentPage === 'animePage') {
        renderAnimeList();
      } else if (currentPage === 'episodesPage') {
        renderEpisodesList();
      }
    });
    
    // Backup/restore
    document.getElementById('backupBtn').addEventListener('click', async () => {
      try {
        const exportData = await api.exportData();
        
        // Create downloadable blob
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        // Create temp download link
        const downloadLink = document.createElement('a');
        downloadLink.href = url;
        const date = new Date().toISOString().slice(0, 10);
        downloadLink.download = `anime_backup_${date}.json`;
        
        // Trigger download
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
        
        URL.revokeObjectURL(url);
        
        showToast('Backup file downloaded successfully');
      } catch (error) {
        showToast('Failed to create backup', 'error');
      }
    });
    
    document.getElementById('chooseFileBtn').addEventListener('click', () => {
      document.getElementById('restoreFileInput').click();
    });
    
    document.getElementById('restoreFileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      document.getElementById('selectedFileInfo').textContent = `Selected: ${file.name} (${Math.round(file.size / 1024)} KB)`;
      document.getElementById('restoreBtn').disabled = false;
    });
    
    document.getElementById('restoreBtn').addEventListener('click', async () => {
      const fileInput = document.getElementById('restoreFileInput');
      const file = fileInput.files[0];
      if (!file) return;
      
      try {
        const reader = new FileReader();
        
        reader.onload = async (event) => {
          try {
            const jsonData = JSON.parse(event.target.result);
            
            // Basic validation
            if (!jsonData.anime || !jsonData.episodes || !jsonData.scheduled) {
              throw new Error('Invalid backup file format');
            }
            
            // Attempt to restore
            const result = await api.importData(jsonData);
            
            // Reset the file input
            fileInput.value = '';
            document.getElementById('selectedFileInfo').textContent = 'No file selected';
            document.getElementById('restoreBtn').disabled = true;
            
            // Show success message
            showToast(`Backup restored: ${result.counts.anime} anime, ${result.counts.episodes} episodes, ${result.counts.scheduled} scheduled items`);
            
            // Reload all data
            await Promise.all([
              api.fetchAnime(),
              api.fetchEpisodes(),
              api.fetchScheduled()
            ]);
            
            // Refresh the current page
            const currentPage = document.querySelector('.page-content:not(.hidden)').id;
            showPage(currentPage.replace('Page', ''));
          } catch (error) {
            showToast(`Failed to restore backup: ${error.message}`, 'error');
          }
        };
        
        reader.readAsText(file);
      } catch (error) {
        showToast(`Failed to read backup file: ${error.message}`, 'error');
      }
    });
    
    // API tab functions
    document.getElementById('copyApiUrlBtn').addEventListener('click', () => {
      const apiUrl = document.getElementById('apiUrlDisplay').value;
      navigator.clipboard.writeText(apiUrl)
        .then(() => showToast('API URL copied to clipboard'))
        .catch(() => showToast('Failed to copy API URL', 'error'));
    });
    
    // Quick action buttons
    document.getElementById('quickAddAnimeBtn').addEventListener('click', () => {
      addAnimeDialog.open();
    });
    
    document.getElementById('quickAddEpisodeBtn').addEventListener('click', () => {
      addEpisodeDialog.open();
    });
    
    document.getElementById('quickScheduleReleaseBtn').addEventListener('click', () => {
      scheduleReleaseDialog.open();
    });
    
    document.getElementById('quickExportDataBtn').addEventListener('click', async () => {
      try {
        const exportData = await api.exportData();
        
        // Create downloadable blob
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        // Create temp download link
        const downloadLink = document.createElement('a');
        downloadLink.href = url;
        const date = new Date().toISOString().slice(0, 10);
        downloadLink.download = `anime_backup_${date}.json`;
        
        // Trigger download
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
        
        URL.revokeObjectURL(url);
        
        showToast('Data exported successfully');
      } catch (error) {
        showToast('Failed to export data', 'error');
      }
    });
    
    // Advanced tab functions
    document.getElementById('clearCacheBtn').addEventListener('click', () => {
      if (confirm('Are you sure you want to clear the cache? This might affect performance but will not delete any data.')) {
        localStorage.removeItem('animeCache');
        showToast('Cache cleared successfully');
      }
    });
    
    document.getElementById('resetDataBtn').addEventListener('click', () => {
      if (confirm('WARNING: This will permanently delete ALL your data. This action cannot be undone. Are you sure you want to continue?')) {
        if (confirm('FINAL WARNING: All anime, episodes, and scheduled releases will be permanently deleted. Are you absolutely sure?')) {
          // Reset all data
          localStorage.clear();
          showToast('All data has been reset. The page will reload.', 'error');
          
          // Reload page after a short delay
          setTimeout(() => {
            window.location.reload();
          }, 2000);
        }
      }
    });
    
    // Common button event listeners
    document.getElementById('desktopBtnAddAnime').addEventListener('click', () => {
      addAnimeDialog.open();
    });
    
    document.getElementById('mobileBtnAddAnime').addEventListener('click', () => {
      addAnimeDialog.open();
      // Close mobile menu
      document.getElementById('mobileMenu').classList.remove('open');
      document.getElementById('drawerOverlay').classList.remove('open');
    });
    
    document.getElementById('animeBtnAdd').addEventListener('click', () => {
      addAnimeDialog.open();
    });
    
    document.getElementById('episodeBtnAdd').addEventListener('click', () => {
      addEpisodeDialog.open();
    });
    
    document.getElementById('scheduledBtnAdd').addEventListener('click', () => {
      scheduleReleaseDialog.open();
    });
    
    // Initialize the app
    async function initializeApp() {
      try {
        // Check if theme preference exists
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
          document.getElementById('themeSelect').value = savedTheme;
        } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.getElementById('themeSelect').value = 'dark';
        }
        
        // Load dashboard data
        await loadDashboardData();
        
        // Show a welcome toast
        showToast('Welcome to Anime API Admin');
      } catch (error) {
        console.error('Error initializing app:', error);
        showToast('Error initializing application', 'error');
      }
    }
    
    // Start the app
    initializeApp();
  </script>
</body>
</html>
